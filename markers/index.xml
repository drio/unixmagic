<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Unix Magic Poster Annotations</title><link>/</link><description>Unix Magic Poster Annotations</description><item><title>Shell</title><link>/#annotation-01-shell</link><description>A gateway to controlling the system</description><content:encoded>&amp;lt;p&amp;gt;The prominent position of the shell in the UNIX Magic poster reflects its
central role in UNIX systems. The shell was (and still is) the primary
interface for interacting with the kernel, serving as the workbench of the UNIX
user. It is an incredibly powerful tool, allowing users to launch and
coordinate processes, perform complex computations, and interface directly with
the operating system.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The shell is not just an interface; it is also a full programming language.
Users can write scripts to automate tasks, control processes, and build
pipelines to process data efficiently. This makes the shell both interactive
and programmable—something remarkably different from other operating systems of
its time.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;While many shells exist today, the original was the Bourne shell (sh), which
laid the foundation for everything that followed.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Finally, I want to emphasize that the shell is the gateway to UNIX power. It is
the first point of contact when learning UNIX, and mastering it unlocks the
system’s full potential. I believe the poster captures this perfectly—the shell
is at the heart of the wizard’s magic because it is the gateway to controlling
the system.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>AWK</title><link>/#annotation-15-awk</link><description>A language designed for text processing.</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/AWK&amp;#34;&amp;gt;AWK&amp;lt;/a&amp;gt; is a domain specific language designed for text
processing, either run directly on files or used as part of a pipeline.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;AWK was created at Bell Labs in the 1970s, and its name is
derived from the surnames of its authors: Alfred Aho, Peter Weinberger and Brian Kernighan.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>B</title><link>/#annotation-18-B</link><description>An early programming language used in the early Multics project.</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/B_(programming_language)&amp;#34;&amp;gt;B&amp;lt;/a&amp;gt; is a programming language
designed for recursive, non-numeric, machine-independent applications.
B was derived from BCPL, and its name may possibly be a contraction of BCPL.
B is an almost extinct programming language, superseded by the more modern C language.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;B was developed at Bell Labs circa 1969 by Ken Thompson and Dennis Ritchie.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>Backpressure</title><link>/#annotation-07-backpressure</link><description>Tell producers to stop sending data because the consumer cannot keep up</description><content:encoded>&amp;lt;p&amp;gt;When two processes communicate over a pipe, the process sending data is the
producer, and the process receiving data is the consumer. The OS maintains a
buffer to temporarily store data if the producer sends data faster than the
consumer can process it. However, if the buffer becomes full, the OS will block
the producer until space is available.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Was that the intention of the artist? You decide—is the valve handle in the
pipes a clever reference to UNIX back pressure, or is that a stretch?&amp;lt;/p&amp;gt;</content:encoded></item><item><title>banner</title><link>/#annotation-40-banner</link><description>A program that outputs ASCII art</description><content:encoded>&amp;lt;p&amp;gt;Is it a coincidence that the poster&amp;amp;rsquo;s title appears in a
&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Banner_(Unix)&amp;#34;&amp;gt;banner&amp;lt;/a&amp;gt;? This Unix program was
designed to convert ordinary text into large ASCII characters for display
purposes.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>boot (or sock?)</title><link>/#annotation-21-boot</link><description>The booting process (or Unix Networking Sockets)</description><content:encoded>&amp;lt;p&amp;gt;I have to admit, this object looks more like a boot than a sock, but I find it
hard to believe that the author would leave out a reference to sockets,
considering how important they are—not only in UNIX but in the history of
operating systems.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;For that reason, I see two possibilities:&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;
&amp;lt;p&amp;gt;If it is a boot, it may represent the booting process of the UNIX operating
system, a fundamental part of bringing the system to life.&amp;lt;/p&amp;gt;
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;
&amp;lt;p&amp;gt;Alternatively, if it is a sock (granted, a thick and oversized one! 😄), it
is likely a playful reference to UNIX network sockets. Network sockets were an
abstraction pioneered by UNIX in BSD UNIX (4.2BSD, 1983). Sockets provided a
unified interface for interprocess communication (IPC), enabling processes to
communicate both locally (on the same machine) via UNIX domain sockets, and
over a network using TCP/IP. This innovation became foundational to modern
networking, and the socket API was later adopted by all major operating
systems, shaping how network programming is done today.&amp;lt;/p&amp;gt;
&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;p&amp;gt;For more on the history of BSD sockets, see &amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Berkeley_sockets&amp;#34;&amp;gt;Berkeley Sockets –
Wikipedia&amp;lt;/a&amp;gt;, or read the
official Linux man page for
&amp;lt;a href=&amp;#34;https://man7.org/linux/man-pages/man2/socket.2.html&amp;#34;&amp;gt;&amp;lt;code&amp;gt;socket()&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>cat</title><link>/#annotation-19-cat</link><description>A standard Unix utility that reads files sequentially, writing them to standard output.</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Cat_(Unix)&amp;#34;&amp;gt;&amp;lt;code&amp;gt;cat&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt; derives its name from its function of
(con)&amp;lt;em&amp;gt;cat&amp;lt;/em&amp;gt;enating files together.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The original version of &amp;lt;code&amp;gt;cat&amp;lt;/code&amp;gt; was part of version 1 of Unix, and written by Ken Thompson and Dennis Ritchie.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>curses</title><link>/#annotation-32-curses</link><description>A terminal control library to aid in creating text user interfaces (TUI)</description><content:encoded>&amp;lt;p&amp;gt;The &amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Curses_(programming_library)&amp;#34;&amp;gt;&amp;lt;code&amp;gt;curses&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt; programming
library provides a layer of abstraction over sending graphical and positioning
data directly to allow for graphical elements and cursor positioning in Unix terminals.
The name is a pun on the term &amp;amp;ldquo;cursor optimization&amp;amp;rdquo;.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The first curses library was written by Ken Arnold and originally released with BSD UNIX.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>Daemons</title><link>/#annotation-08-daemons</link><description>Service processes that run in the background and supervise the system or provide functionality to other processes</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Daemon_(computing)&amp;#34;&amp;gt;Daemons&amp;lt;/a&amp;gt; are programs that run in the background
and are often started at system boot time. They respond to network requests, hardware activity,
or other programs by performing some task. Daemons such as cron may also perform
defined tasks at scheduled times.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The term was coined by the programmers at MIT&amp;amp;rsquo;s Project MAC. It is inspired by Maxwell&amp;amp;rsquo;s demon and
greek mythology, acting as a metaphor for a supernatural being working in the background.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>dates</title><link>/#annotation-26-dates</link><description>A command to display and set the system date</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://man7.org/linux/man-pages/man1/date.1.html&amp;#34;&amp;gt;&amp;lt;code&amp;gt;date&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt; is a command to display and set a UNIX system date.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Unix time is currently defined as the number of non-leap seconds which have passed since 00:00:00 UTC on Thursday, 1 January 1970,
which is referred to as the Unix epoch.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The earliest versions of Unix time had a 32-bit integer incrementing at a rate of 60 Hz, which was the rate of the system clock
on the hardware of the early Unix systems.
Timestamps stored this way could only represent a range of a little over two and a quarter years.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The current epoch of 1 January 1970 00:00:00 UTC was selected arbitrarily by Unix engineers because it was considered a
convenient date to work with.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>diff</title><link>/#annotation-33-diff</link><description>A utility to find the differences between contents of a file</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Diff&amp;#34;&amp;gt;&amp;lt;code&amp;gt;diff&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt; is a data comparison tool that computes
and displays the differences in the contents of files.
&amp;lt;code&amp;gt;diff&amp;lt;/code&amp;gt; is line oriented and is often used to determine changes between two versions
of the same file.
For example, &amp;lt;code&amp;gt;diff&amp;lt;/code&amp;gt; can be used to find which lines have changed in a source file,
allowing for only transmission of the changes, rather than the whole file.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;diff&amp;lt;/code&amp;gt; as developed in the early 1970s at Bell Labs.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>Filesystem hierarchy</title><link>/#annotation-38-tree-graph</link><description>Navigating the filesystem</description><content:encoded>&amp;lt;p&amp;gt;The tree-like shape of the liquid the wizard is manipulating may be a reference to
the UNIX filesystem hierarchy. UNIX organizes files and directories in a tree
structure, starting from the root (&amp;lt;code&amp;gt;/&amp;lt;/code&amp;gt;) and branching into subdirectories.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Navigating this structure is a fundamental part of working with UNIX, typically done
through the shell using commands like &amp;lt;code&amp;gt;cd&amp;lt;/code&amp;gt;, &amp;lt;code&amp;gt;ls&amp;lt;/code&amp;gt;, and &amp;lt;code&amp;gt;pwd&amp;lt;/code&amp;gt;. The tree shape could
symbolize this concept, visually representing how users move through directories,
access files, and execute commands.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Alternatively, the branching form could represent recursive operations or the
parent-child relationships in process trees, both key concepts in UNIX systems.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Some modern readers might associate the tree shape with version control systems like
Git, where branching is a common visual metaphor. However, this is likely not the
intended reference, as branching version control workflows were not as prevalent in
the UNIX world at the time the poster was created. Tools like SCCS (1972) and RCS
(1982) were available, but they focused more on linear versioning and file locking
than the branching models popular today.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>fork</title><link>/#annotation-13-fork</link><description>An operation whereby a process creates a copy of itself</description><content:encoded>&amp;lt;p&amp;gt;In multitasking operating systems, processes need a way to create new processes.
&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Fork_(system_call)&amp;#34;&amp;gt;Forking&amp;lt;/a&amp;gt; a process is typically the
only way of doing so in Unix-like systems.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;One of the earliest references to a fork concept appeared in A Multiprocessor
System Design by Melvin Conway, published in 1962.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>Jfo nroff</title><link>/#annotation-24-jfo-nroff</link><description>A text formatting program that produces fixed width output for printers and terminals</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Nroff&amp;#34;&amp;gt;&amp;lt;code&amp;gt;nroff&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt;, short for &amp;amp;ldquo;new roff&amp;amp;rdquo;
is a text-formatting program produces output suitable for simple fixed-width
printers and terminal windows.
It is an integral part of the Unix help system, being used to format man pages for display.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The letters &amp;lt;em&amp;gt;Jfo&amp;lt;/em&amp;gt; stand for Joseph Frank Ossanna
who created the original version of &amp;lt;code&amp;gt;nroff&amp;lt;/code&amp;gt; for Version 2 Unix.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>Legendary figures</title><link>/#annotation-05-kandr</link><description>Legendary figures in Unix history</description><content:encoded>&amp;lt;p&amp;gt;In the context of Unix history these three sets of initials refer to legendary
figures in the creation and development of Unix:&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;dmr: Dennis M. Ritchie, co-creator of Unix and creator of the C programming
language.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;kt: Ken Thompson (often just “ken” in historical Unix references), co-creator
of Unix alongside Ritchie.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;bwk: Brian W. Kernighan, co-author of several influential Unix programs and
books (including “The C Programming Language” and “The UNIX Programming
Environment”).&amp;lt;/p&amp;gt;</content:encoded></item><item><title>login</title><link>/#annotation-30-login</link><description>The gateway into the system</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;login&amp;lt;/code&amp;gt; is the gateway into the system. It authenticates the user, initializes
the environment by changing to the user’s home directory, and spawns a process
running as the user (with their &amp;lt;code&amp;gt;uid&amp;lt;/code&amp;gt; and &amp;lt;code&amp;gt;gid&amp;lt;/code&amp;gt;), using their shell of choice.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Additionally, the standard input and output need to be attached to a terminal:
this could be a &amp;lt;strong&amp;gt;pseudo-terminal&amp;lt;/strong&amp;gt; (if you are in a graphical interface or
using &amp;lt;code&amp;gt;ssh&amp;lt;/code&amp;gt;), or a &amp;lt;strong&amp;gt;physical terminal&amp;lt;/strong&amp;gt; (as was common at the time).&amp;lt;/p&amp;gt;</content:encoded></item><item><title>make</title><link>/#annotation-22-make</link><description>A software development tool to perform ordered actions and manage dependencies</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Make_(software)&amp;#34;&amp;gt;Make&amp;lt;/a&amp;gt; is a command line interface
that reads in a configuration &amp;lt;code&amp;gt;Makefile&amp;lt;/code&amp;gt; that is often used in code executable
compilation and automation.
Before Make, building on Unix mostly consisted of shell scripts written for each program&amp;amp;rsquo;s codebase.
Make&amp;amp;rsquo;s dependency ordering and out-of-date checking makes the build process more robust and more efficient.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Stuart Feldman was the original author of Make, completing an early version in April 1976 at
Bell Labs.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>man</title><link>/#annotation-02-man</link><description>Command to get detailed documentation of different Unix components, including other cmds.</description><content:encoded>&amp;lt;p&amp;gt;The &amp;lt;a href=&amp;#34;https://man7.org/linux/man-pages/man1/man.1.html&amp;#34;&amp;gt;man(1)&amp;lt;/a&amp;gt;
command (short for manual) is used to display online reference manuals (man
pages) for commands, system calls, configuration files, and other aspects of
the system. man provides detailed documentation on how to use a command,
including its options, usage examples, related files, and other pertinent
details.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;There&amp;amp;rsquo;s some ambiguity as to what the interpretation of the man in the window
could represent.
The man is holding a scythe, which could represent &amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Zombie_process&amp;#34;&amp;gt;reaping a process&amp;lt;/a&amp;gt;.
Under Unix like systems, process reaping is when a parent process reads
the exit status of a spawned child process, allowing the child process
to be removed from the process table.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Others have suggested that the man could represent a &amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Hacker&amp;#34;&amp;gt;hacker&amp;lt;/a&amp;gt;,
a term used to mean a skilled or clever programmer.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>mbox</title><link>/#annotation-29-mbox</link><description>The mail system format</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;mbox&amp;lt;/code&amp;gt; is a reference to the mail format from the early days of UNIX. UNIX was
one of the first operating systems to come with built-in email capabilities,
and it did so while staying true to its mantra: &amp;amp;ldquo;everything is a file.&amp;amp;rdquo; In the
&amp;lt;code&amp;gt;mbox&amp;lt;/code&amp;gt; format, all email messages are stored in a single file, with new
messages simply appended to the end. By default, users&amp;amp;rsquo; mail was stored in
&amp;lt;code&amp;gt;/usr/mail/&amp;amp;lt;username&amp;amp;gt;&amp;lt;/code&amp;gt;. This design naturally enabled the integration of
system logs and notifications to be sent via email—further embedding email as
a core part of the UNIX experience.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>Memory leaks</title><link>/#annotation-04-leak</link><description>Improper managing of memory by a computer program</description><content:encoded>&amp;lt;p&amp;gt;A memory leak occurs when a computer program improperly manages memory
allocation, failing to release memory that’s no longer needed. Over time, these
un-freed allocations accumulate, reducing the amount of available memory for
other processes and potentially leading to slowdowns or crashes.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>null</title><link>/#annotation-10-null</link><description>The null device is a device file that discards all data written to it but reports that the write operation succeeded.</description><content:encoded>&amp;lt;p&amp;gt;The &amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Null_device&amp;#34;&amp;gt;Null device&amp;lt;/a&amp;gt; is a device file that discards all data written
to it but reports that the write operation succeeded.
This device is called /dev/null on Unix and Unix-like systems.
The null device is typically used for disposing of unwanted output streams of a process, or as a convenient empty file for input streams.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>Oregano</title><link>/#annotation-11-oregano</link><description>The Oregano incident</description><content:encoded>&amp;lt;p&amp;gt;From &amp;lt;a href=&amp;#34;https://groups.google.com/g/comp.unix.wizards/c/qkiqSJWgEPE/m/E5BwZYMvXwAJ&amp;#34;&amp;gt;Sarah Groves Hobart&amp;lt;/a&amp;gt;:&amp;lt;/p&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;The oregano is reputedly referring to an incident in which one of the
original folks involved with BSD was hassled for coming across the
Canadian/U.S. border with a bag of what was assumed to be an illegal
substance, and turned out to be oregano.&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;</content:encoded></item><item><title>Overflows</title><link>/#annotation-36-overflows</link><description>Buffer overflows</description><content:encoded>&amp;lt;p&amp;gt;This may be a bit of a stretch, but considering how prevalent buffer overflows
have been in the history of UNIX, the imagery might be intentional. The
overflowing liquid from the shell could be a visual reference to a buffer overflow.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;A buffer overflow occurs when a program writes more data into a buffer (a fixed
block of memory) than it can hold. The excess data &amp;amp;ldquo;spills over&amp;amp;rdquo; into adjacent
memory, often overwriting critical information like return addresses, which can
cause crashes or open security vulnerabilities. Buffer overflows were (and still
are) a classic type of exploit in C programming on UNIX systems.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;For more information, see
&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Buffer_overflow&amp;#34;&amp;gt;Buffer overflow – Wikipedia&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>Pipes</title><link>/#annotation-03-pipes</link><description>Connect cmd outputs to cmd inputs to create complex pipelines</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Pipeline_(Unix)&amp;#34;&amp;gt;Pipes&amp;lt;/a&amp;gt; are a
foundational feature in Unix that enable you to combine simple utilities into
more powerful workflows. By passing data from one command’s output to another
command’s input, pipes allow you to quickly create flexible, efficient, and
maintainable solutions directly at the command line. They are denoted in the
shell by the vertical bar character (|).&amp;lt;/p&amp;gt;</content:encoded></item><item><title>pwd</title><link>/#annotation-28-pwd</link><description>A cmd to determine your location in the filesystem</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://man7.org/linux/man-pages/man1/pwd.1.html&amp;#34;&amp;gt;&amp;lt;code&amp;gt;pwd&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt; is a simple command
that shows your current location in the filesystem. Is it a coincidence that
&amp;lt;code&amp;gt;pwd&amp;lt;/code&amp;gt; is visually presented in a box? Maybe. But perhaps it’s a visual clue,
suggesting that &amp;lt;code&amp;gt;pwd&amp;lt;/code&amp;gt; is a small, self-contained tool—like many classic UNIX
commands.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>root</title><link>/#annotation-25-root</link><description>The administrator account on UNIX systems</description><content:encoded>&amp;lt;p&amp;gt;The root user is the name often given to the administrator or superuser account
on UNIX systems.
In Unix-like systems, root is the conventional name of the user who has all rights or
permissions to all files and programs in all modes (e.g. single- or multi-user).
The root user can do many things an ordinary user cannot, such as changing the
ownership of files and binding to network ports numbered below 1024.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>Shell script</title><link>/#annotation-14-shell-script</link><description>The shell language</description><content:encoded>&amp;lt;p&amp;gt;A &amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Shell_script&amp;#34;&amp;gt;shell script&amp;lt;/a&amp;gt; is a computer
program designed to be run by a Unix shell. The term is also used more
generally to mean the automated mode of running an operating system shell.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>Shell's symbols</title><link>/#annotation-35-shell-symbols</link><description>Symbols of the shell</description><content:encoded>&amp;lt;h3 id=&amp;#34;shell-symbols-on-the-wizards-cloak&amp;#34;&amp;gt;Shell Symbols on the Wizard&amp;amp;rsquo;s Cloak&amp;lt;/h3&amp;gt;
&amp;lt;p&amp;gt;The wizard’s cloak is decorated with symbols that represent some of the most
important special characters used in the UNIX shell. These symbols are the
&amp;amp;ldquo;runes&amp;amp;rdquo; of UNIX power, allowing users to combine commands, redirect input and
output, and control processes with precision. Mastery of these symbols is part
of what transforms a regular user into a &amp;amp;ldquo;UNIX wizard.&amp;amp;rdquo;&amp;lt;/p&amp;gt;
&amp;lt;h4 id=&amp;#34;--job-control&amp;#34;&amp;gt;&amp;lt;code&amp;gt;%&amp;lt;/code&amp;gt; – Job Control&amp;lt;/h4&amp;gt;
&amp;lt;p&amp;gt;Used to &amp;lt;strong&amp;gt;refer to background jobs in the shell&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;jobs&amp;lt;/code&amp;gt; → List background jobs.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;fg %1&amp;lt;/code&amp;gt; → Bring &amp;lt;strong&amp;gt;job 1 to the foreground&amp;lt;/strong&amp;gt;.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;bg %2&amp;lt;/code&amp;gt; → Resume &amp;lt;strong&amp;gt;job 2 in the background&amp;lt;/strong&amp;gt;.&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;h4 id=&amp;#34;--variable-expansion--shell-prompt&amp;#34;&amp;gt;&amp;lt;code&amp;gt;$&amp;lt;/code&amp;gt; – Variable Expansion &amp;amp;amp; Shell Prompt&amp;lt;/h4&amp;gt;
&amp;lt;p&amp;gt;Represents &amp;lt;strong&amp;gt;variables and parameter substitution&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;$HOME&amp;lt;/code&amp;gt; → Expands to &amp;lt;strong&amp;gt;the value of the &amp;lt;code&amp;gt;HOME&amp;lt;/code&amp;gt; environment variable&amp;lt;/strong&amp;gt;.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;$?&amp;lt;/code&amp;gt; → Shows &amp;lt;strong&amp;gt;the exit status of the last command&amp;lt;/strong&amp;gt;.&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;p&amp;gt;Also often &amp;lt;strong&amp;gt;appears as the shell prompt&amp;lt;/strong&amp;gt; for &amp;lt;strong&amp;gt;a regular user&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;h4 id=&amp;#34;--output-redirection&amp;#34;&amp;gt;&amp;lt;code&amp;gt;&amp;amp;gt;&amp;lt;/code&amp;gt; – Output Redirection&amp;lt;/h4&amp;gt;
&amp;lt;p&amp;gt;Redirects &amp;lt;strong&amp;gt;standard output to a file&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ls &amp;amp;gt; files.txt&amp;lt;/code&amp;gt; → Writes the &amp;lt;strong&amp;gt;output of &amp;lt;code&amp;gt;ls&amp;lt;/code&amp;gt; into &amp;lt;code&amp;gt;files.txt&amp;lt;/code&amp;gt;&amp;lt;/strong&amp;gt; (overwriting it).&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;h4 id=&amp;#34;--input-redirection&amp;#34;&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;&amp;lt;/code&amp;gt; – Input Redirection&amp;lt;/h4&amp;gt;
&amp;lt;p&amp;gt;Redirects &amp;lt;strong&amp;gt;standard input from a file&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;sort &amp;amp;lt; input.txt&amp;lt;/code&amp;gt; → Reads &amp;lt;strong&amp;gt;input from &amp;lt;code&amp;gt;input.txt&amp;lt;/code&amp;gt; instead of the keyboard&amp;lt;/strong&amp;gt;.&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;h4 id=&amp;#34;--wildcard-glob&amp;#34;&amp;gt;&amp;lt;code&amp;gt;*&amp;lt;/code&amp;gt; – Wildcard (Glob)&amp;lt;/h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Matches any number of characters&amp;lt;/strong&amp;gt; in filenames.&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ls *.txt&amp;lt;/code&amp;gt; → Lists &amp;lt;strong&amp;gt;all files ending in &amp;lt;code&amp;gt;.txt&amp;lt;/code&amp;gt;&amp;lt;/strong&amp;gt;.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;rm *&amp;lt;/code&amp;gt; → &amp;lt;strong&amp;gt;Deletes all files in the current directory&amp;lt;/strong&amp;gt; (Dangerous!).&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;h4 id=&amp;#34;--history-expansion&amp;#34;&amp;gt;&amp;lt;code&amp;gt;!&amp;lt;/code&amp;gt; – History Expansion&amp;lt;/h4&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Expands to previously executed commands&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;!!&amp;lt;/code&amp;gt; → Repeats &amp;lt;strong&amp;gt;the last command&amp;lt;/strong&amp;gt;.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;!ls&amp;lt;/code&amp;gt; → Repeats &amp;lt;strong&amp;gt;the last command starting with &amp;lt;code&amp;gt;ls&amp;lt;/code&amp;gt;&amp;lt;/strong&amp;gt;.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;!$&amp;lt;/code&amp;gt; → Expands &amp;lt;strong&amp;gt;to the last argument of the previous command&amp;lt;/strong&amp;gt;.&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;h4 id=&amp;#34;---test--conditional-expressions&amp;#34;&amp;gt;&amp;lt;code&amp;gt;[&amp;lt;/code&amp;gt; &amp;lt;code&amp;gt;]&amp;lt;/code&amp;gt; – Test / Conditional Expressions&amp;lt;/h4&amp;gt;
&amp;lt;p&amp;gt;Used &amp;lt;strong&amp;gt;in shell conditionals&amp;lt;/strong&amp;gt; and &amp;lt;strong&amp;gt;&amp;lt;code&amp;gt;if&amp;lt;/code&amp;gt; statements&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;[ -f file.txt ]&amp;lt;/code&amp;gt; → &amp;lt;strong&amp;gt;Tests if &amp;lt;code&amp;gt;file.txt&amp;lt;/code&amp;gt; is a regular file&amp;lt;/strong&amp;gt;.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Common &amp;lt;strong&amp;gt;in shell scripting&amp;lt;/strong&amp;gt;:
&amp;lt;div class=&amp;#34;highlight&amp;#34;&amp;gt;&amp;lt;pre tabindex=&amp;#34;0&amp;#34; style=&amp;#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&amp;#34;&amp;gt;&amp;lt;code class=&amp;#34;language-bash&amp;#34; data-lang=&amp;#34;bash&amp;#34;&amp;gt;&amp;lt;span style=&amp;#34;display:flex;&amp;#34;&amp;gt;&amp;lt;span&amp;gt;&amp;lt;span style=&amp;#34;color:#66d9ef&amp;#34;&amp;gt;if&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;#34;color:#f92672&amp;#34;&amp;gt;[&amp;lt;/span&amp;gt; -f file.txt &amp;lt;span style=&amp;#34;color:#f92672&amp;#34;&amp;gt;]&amp;lt;/span&amp;gt;; &amp;lt;span style=&amp;#34;color:#66d9ef&amp;#34;&amp;gt;then&amp;lt;/span&amp;gt;
&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;#34;display:flex;&amp;#34;&amp;gt;&amp;lt;span&amp;gt; echo &amp;lt;span style=&amp;#34;color:#e6db74&amp;#34;&amp;gt;&amp;amp;#34;File exists!&amp;amp;#34;&amp;lt;/span&amp;gt;
&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;#34;display:flex;&amp;#34;&amp;gt;&amp;lt;span&amp;gt;&amp;lt;span style=&amp;#34;color:#66d9ef&amp;#34;&amp;gt;fi&amp;lt;/span&amp;gt;
&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;</content:encoded></item><item><title>skull</title><link>/#annotation-39-skull</link><description>Redirecting to stdout/stdin</description><content:encoded>&amp;lt;p&amp;gt;The skull connected to the shell may symbolize &amp;lt;code&amp;gt;/dev/null&amp;lt;/code&amp;gt;, the special UNIX
device that discards all data written to it.
In UNIX, redirecting output to
&amp;lt;code&amp;gt;/dev/null&amp;lt;/code&amp;gt; effectively sends it into a &amp;amp;ldquo;black hole,&amp;amp;rdquo; where it is lost
forever.
Output redirection is part of a broader
&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Standard_streams&amp;#34;&amp;gt;standard stream&amp;lt;/a&amp;gt; UNIX concept that
allows outputs of one process to be redirected to the input of another.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Another interpretation is that the spigot is reminiscent of a gargoyle, perhaps
referencing a UNIX &amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Daemon_(computing)&amp;#34;&amp;gt;daemon&amp;lt;/a&amp;gt;
process.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;See the (&amp;lt;a href=&amp;#34;#annotation-10-null&amp;#34;&amp;gt;/dev/null&amp;lt;/a&amp;gt;) mark.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>spawn</title><link>/#annotation-23-spawn</link><description>An operation in which a new child process is created</description><content:encoded>&amp;lt;p&amp;gt;Spawning is the process of loading and executing a new child process.
Closely related is the idea of &amp;lt;code&amp;gt;fork&amp;lt;/code&amp;gt; and &amp;lt;code&amp;gt;exec&amp;lt;/code&amp;gt; that can be used
to simulate spawning, by forking a process, having the parent terminate
and &amp;lt;code&amp;gt;exec&amp;lt;/code&amp;gt;ing the child into the desired spawn process.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;POSIX allow for the concept of spawning by itself that can be made
to be more efficient than &amp;lt;code&amp;gt;fork&amp;lt;/code&amp;gt; and &amp;lt;code&amp;gt;exec&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The spawn metaphor had its early use in the VMS operating system from 1977.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>spells</title><link>/#annotation-31-spells</link><description>A command to check spelling</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Spell_(Unix)&amp;#34;&amp;gt;&amp;lt;code&amp;gt;spell&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt; is the standard English
language spell checker for Unix and other Unix-like operating systems.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The original version was written by Stephen C. Johnson for Version 6 UNIX while at Bell Labs in 1976.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>spool</title><link>/#annotation-16-spool</link><description>/usr/spool</description><content:encoded>&amp;lt;p&amp;gt;This references &amp;lt;code&amp;gt;/usr/spool&amp;lt;/code&amp;gt;, a directory used for temporary storage of data
that was waiting to be processed.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Thank you to Andrew Tannenbaum for pointing out that threads were not available
in the UNIX early days. Andew also sent me a link to &amp;lt;a href=&amp;#34;https://commandcenter.blogspot.com/2020/01/unix-quiz.html&amp;#34;&amp;gt;Rob Pike&amp;amp;rsquo;s UNIX
quiz&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>su</title><link>/#annotation-09-su</link><description>Command to switch your identity</description><content:encoded>&amp;lt;p&amp;gt;The &amp;lt;a href=&amp;#34;https://www.man7.org/linux/man-pages/man1/su.1.html&amp;#34;&amp;gt;su&amp;lt;/a&amp;gt; command (short for “substitute user” or
“switch user”) is used to start a shell under a different user account.
Typically, one of the most common uses of su is switching to the superuser
(root) account to gain administrative privileges.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>tar</title><link>/#annotation-12-tar</link><description>A software utility for collecting multiple files into a single archive file.</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Tar_(computing)&amp;#34;&amp;gt;Tar&amp;lt;/a&amp;gt; is a software tool for collecting multiple
files into a single archive file, often called a tarball.
The name is derived from &amp;amp;ldquo;tape archive&amp;amp;rdquo;, as it was originally developed to write
data to sequential I/O devices with no file system of their own, such as devices that use magnetic tape.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The command-line utility was first introduced in the Version 7 Unix in January 1979, replacing the &amp;lt;code&amp;gt;tp&amp;lt;/code&amp;gt; program (which in turn replaced &amp;lt;code&amp;gt;tap&amp;lt;/code&amp;gt;).&amp;lt;/p&amp;gt;</content:encoded></item><item><title>tee</title><link>/#annotation-37-tee</link><description>The T-junctions in the pipes, possibly a reference to the tee command.</description><content:encoded>&amp;lt;p&amp;gt;The T shape of the pipes may also reference the
&amp;lt;a href=&amp;#34;https://man7.org/linux/man-pages/man1/tee.1.html&amp;#34;&amp;gt;&amp;lt;code&amp;gt;tee&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt; command, a classic
utility in UNIX. The &amp;lt;code&amp;gt;tee&amp;lt;/code&amp;gt; command is used to split the output of a command,
sending it to both a file and the next command in a pipeline.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>The c programming language</title><link>/#annotation-06-c</link><description>A key programming language in the creation of Unix</description><content:encoded>&amp;lt;p&amp;gt;C is deeply intertwined with the history and development of the Unix operating
system. Created by Dennis M. Ritchie at Bell Labs in the early 1970s, C was
used to rewrite Unix from low-level assembly into a higher-level language. This
shift made Unix significantly more portable across different hardware
platforms, fueling its rapid adoption in academia and industry. Over time, C
evolved into one of the most influential and widely used programming languages
in history.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>traps</title><link>/#annotation-34-traps</link><description>An inter-process message sent to a running program</description><content:encoded>&amp;lt;p&amp;gt;Traps, or &amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Signal_(IPC)&amp;#34;&amp;gt;signals&amp;lt;/a&amp;gt;, are sent
from the kernel to a process, notifying the process of an event.
Common signals are interrupt, terminate or kill, with some signal
handling useful for inter-process communication and coordination.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>troff</title><link>/#annotation-17-troff</link><description>A program in formatting documents for the document processing system.</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Troff&amp;#34;&amp;gt;Troff&amp;lt;/a&amp;gt; is the major component of a document processing system developed by Bell Labs for the Unix operating system.
Troff stands for &amp;amp;ldquo;typesetter roff&amp;amp;rdquo;, developed as a descendant to
&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Roff_(software)&amp;#34;&amp;gt;&amp;lt;code&amp;gt;roff&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt;, where &amp;lt;code&amp;gt;roff&amp;lt;/code&amp;gt; was
a Unix version of one of the earliest text formatting programs called &amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/TYPSET_and_RUNOFF&amp;#34;&amp;gt;&amp;lt;code&amp;gt;RUNOFF&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt;.
A typical distribution of troff includes macros for many document styles, including ones for the Unix &amp;lt;code&amp;gt;man&amp;lt;/code&amp;gt; pages.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Troff was developed by Bell Labs in the 1970s, where Joseph Ossanna created &amp;lt;code&amp;gt;troff&amp;lt;/code&amp;gt; by modifying &amp;lt;code&amp;gt;nroff&amp;lt;/code&amp;gt; to support multiple fonts and proportional spacing.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>uucp</title><link>/#annotation-20-uucp</link><description>A Unix program for file copy requests.</description><content:encoded>&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/UUCP&amp;#34;&amp;gt;&amp;lt;code&amp;gt;uucp&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt; is one of the programs in the suite of Unix-to-Unix Copy programs.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;UUCP was originally written at AT&amp;amp;amp;T Bell Laboratories by Mike Lesk.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>wall</title><link>/#annotation-41-wall</link><description>Utility to send a message to all users</description><content:encoded>&amp;lt;p&amp;gt;The &amp;lt;a href=&amp;#34;https://www.man7.org/linux/man-pages/man1/wall.1.html&amp;#34;&amp;gt;wall&amp;lt;/a&amp;gt; command is a command-line utility that displays the contents of the specified file or otherwise its standard input on the terminals of all currently logged-in users. It is typically used by root to send out shutting down message to all users just before poweroff.&amp;lt;/p&amp;gt;</content:encoded></item><item><title>whoami</title><link>/#annotation-27-whoami</link><description>A command to provide the effective username of the current user</description><content:encoded>&amp;lt;p&amp;gt;Users on UNIX systems may want to
switch to other accounts, allowing for switching roles, escalation or deescalation of
privileges or might be logging into multiple machines across networks.
The &amp;lt;a href=&amp;#34;https://en.wikipedia.org/wiki/Whoami&amp;#34;&amp;gt;&amp;lt;code&amp;gt;whoami&amp;lt;/code&amp;gt;&amp;lt;/a&amp;gt; is a command to tell the invoker
what user they are logged in as.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The earliest versions were created in 2.9 BSD.&amp;lt;/p&amp;gt;</content:encoded></item></channel></rss>