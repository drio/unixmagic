<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.148.1"><meta charset=UTF-8><link rel=icon type=image/x-icon href=./favicon.ico><link rel=apple-touch-icon sizes=180x180 href=./favicon.png><meta name=viewport content="width=device-width,initial-scale=1"><title>Unix Magic Poster Annotations</title><style>body{opacity:1;transition:none}html,body{margin:0;padding:0;width:100%;min-height:100vh;font-family:Arial,sans-serif;background-color:#fff;scroll-behavior:smooth;overflow-x:hidden}a{color:#bc4f5f;text-decoration:none}a:hover{text-decoration:underline;color:#a53f4f}.header{display:flex;align-items:center;gap:10px;justify-content:center;padding-top:15px}.header-link{text-decoration:none;font-size:14px;color:#666;transition:color .2s ease-in-out}.header-link:hover{color:#bc4f5f}.header img{width:20px;max-width:10vw;height:auto;transition:filter .3s ease-in-out;opacity:.5}.header img:hover{opacity:1}.poster-info-container{display:flex;justify-content:center;margin:0 auto;max-width:800px}.poster-info{max-width:800px;font-size:15px;color:#333;text-align:justify;padding:12px}.poster-info a{color:#bc4f5f;text-decoration:none}.poster-info a:hover{text-decoration:underline}.image-container{position:relative;width:100%;display:flex;justify-content:center}img{max-width:100%;max-height:100vh;display:block;margin:auto}.marker{position:absolute;width:18px;height:18px;background:rgba(220,53,69,.75);color:#fff;font-size:12px;font-weight:700;text-align:center;line-height:18px;border-radius:50%;cursor:pointer;transform:translate(-50%,-50%);opacity:0;animation:fadeIn 3s ease-out forwards}@keyframes fadeIn{from{opacity:0;transform:translate(-50%,-50%)scale(.7)}to{opacity:.8;transform:translate(-50%,-50%)scale(1)}}.marker:hover{opacity:1;transform:translate(-50%,-50%)scale(1.2)}.annotations{max-width:800px;margin:0 auto;padding:10px}.annotation{background-color:#e8e8e8;border-radius:8px;padding:12px;margin-bottom:15px;border:1px solid #e0e0e0}.annotation-header{display:flex;align-items:flex-start;gap:12px;margin-bottom:8px}.annotation-number{background-color:#bc4f5f;color:#fff;font-size:14px;width:24px;height:24px;line-height:24px;text-align:center;border-radius:50%;display:inline-block;flex-shrink:0}.annotation-text{display:flex;flex-direction:column}.annotation-title{font-size:16px;font-weight:700}.annotation-description{font-size:14px;color:#333}.annotation-footer{display:flex;justify-content:flex-end;margin-top:8px}.back-to-top{text-decoration:none;font-size:18px;display:inline-block;color:inherit;cursor:pointer}.back-to-top:hover{text-decoration:none}.side-container{position:fixed;top:0;left:0;width:min(70vw,700px);max-height:90vh;background:#fff;box-shadow:4px 0 15px rgba(0,0,0,.2);padding:20px;transform:translateX(-100%);transition:transform .3s ease-in-out;z-index:1000;visibility:hidden;overflow:hidden;border-top-right-radius:10px;border-bottom-right-radius:10px;backdrop-filter:blur(12px);display:flex;flex-direction:column}.side-container.active{transform:translateX(0);visibility:visible}.close-btn{position:absolute;top:10px;right:10px;border:none;background:0 0;font-size:22px;font-weight:700;cursor:pointer;color:#777;transition:color .2s ease-in-out;z-index:10}.close-btn:hover{color:#555}.side-content .annotation{max-height:85vh;overflow-y:auto;padding-top:10px;padding-right:10px;font-size:16px;line-height:1.5;color:#222;scrollbar-width:none;-ms-overflow-style:none;border:none;background-color:#fff}.side-content::-webkit-scrollbar{display:none}.footer{text-align:center;padding:20px;font-size:14px;color:#555}.footer a{text-decoration:none;color:salmon;font-weight:700}#loading{position:fixed;opacity:1;inset:0;background:#fff;display:flex;justify-content:center;align-items:center;font-size:20px;z-index:99999}</style></head><body><div id=loading>Get ready for some Unix magic... 🪄</div><div class=header><a href=https://github.com/drio/unixmagic target=_blank><img src=github.svg alt=github>
</a><a href=./index.xml class=rss-link title="RSS Feed"><img src=rss.svg> </a><a href=#poster-info class=header-link>about</a></div><div class=image-container id=poster-container><img id=poster src=./ump.webp alt="Unix Magic Poster"><div class=marker data-left=40% data-top=69% data-id=annotation-01-shell>1</div><div class=marker data-left=64.5% data-top=89% data-id=annotation-15-awk>15</div><div class=marker data-left=80% data-top=83% data-id=annotation-18-B>18</div><div class=marker data-left=11% data-top=22% data-id=annotation-07-backpressure>7</div><div class=marker data-left=21% data-top=10% data-id=annotation-40-banner>40</div><div class=marker data-left=17% data-top=58% data-id=annotation-21-boot>21</div><div class=marker data-left=89% data-top=83% data-id=annotation-19-cat>19</div><div class=marker data-left=78% data-top=27% data-id=annotation-32-curses>32</div><div class=marker data-left=66% data-top=29% data-id=annotation-08-daemons>8</div><div class=marker data-left=84% data-top=46% data-id=annotation-26-dates>26</div><div class=marker data-left=12% data-top=76% data-id=annotation-33-diff>33</div><div class=marker data-left=50% data-top=47% data-id=annotation-38-tree-graph>38</div><div class=marker data-left=25% data-top=90% data-id=annotation-13-fork>13</div><div class=marker data-left=76% data-top=40% data-id=annotation-24-jfo-nroff>24</div><div class=marker data-left=56% data-top=29% data-id=annotation-05-kandr>5</div><div class=marker data-left=83% data-top=57% data-id=annotation-30-login>30</div><div class=marker data-left=83% data-top=64% data-id=annotation-22-make>22</div><div class=marker data-left=15% data-top=51% data-id=annotation-02-man>2</div><div class=marker data-left=89% data-top=32% data-id=annotation-29-mbox>29</div><div class=marker data-left=25% data-top=29% data-id=annotation-04-leak>4</div><div class=marker data-left=42.5% data-top=83% data-id=annotation-10-null>10</div><div class=marker data-left=35% data-top=88% data-id=annotation-11-oregano>11</div><div class=marker data-left=50% data-top=62% data-id=annotation-36-overflows>36</div><div class=marker data-left=45% data-top=24% data-id=annotation-03-pipes>3</div><div class=marker data-left=79% data-top=33% data-id=annotation-28-pwd>28</div><div class=marker data-left=89% data-top=39% data-id=annotation-25-root>25</div><div class=marker data-left=44.5% data-top=90% data-id=annotation-14-shell-script>14</div><div class=marker data-left=25% data-top=46% data-id=annotation-35-shell-symbols>35</div><div class=marker data-left=50% data-top=77% data-id=annotation-39-skull>39</div><div class=marker data-left=66% data-top=39% data-id=annotation-23-spawn>23</div><div class=marker data-left=75% data-top=26% data-id=annotation-31-spells>31</div><div class=marker data-left=67% data-top=85.5% data-id=annotation-16-spool>16</div><div class=marker data-left=47% data-top=30% data-id=annotation-09-su>9</div><div class=marker data-left=16% data-top=85% data-id=annotation-12-tar>12</div><div class=marker data-left=71% data-top=19% data-id=annotation-37-tee>37</div><div class=marker data-left=89% data-top=67% data-id=annotation-06-c>6</div><div class=marker data-left=73% data-top=33% data-id=annotation-34-traps>34</div><div class=marker data-left=70.5% data-top=82% data-id=annotation-17-troff>17</div><div class=marker data-left=77% data-top=69% data-id=annotation-20-uucp>20</div><div class=marker data-left=40% data-top=29% data-id=annotation-41-wall>41</div><div class=marker data-left=71% data-top=26% data-id=annotation-27-whoami>27</div></div><div class=side-container id=annotation-01-shell><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>1</span><div class=annotation-text><div class=annotation-title>Shell</div><div class=annotation-description>A gateway to controlling the system</div></div></div><div class=annotation-body><p>The prominent position of the shell in the UNIX Magic poster reflects its
central role in UNIX systems. The shell was (and still is) the primary
interface for interacting with the kernel, serving as the workbench of the UNIX
user. It is an incredibly powerful tool, allowing users to launch and
coordinate processes, perform complex computations, and interface directly with
the operating system.</p><p>The shell is not just an interface; it is also a full programming language.
Users can write scripts to automate tasks, control processes, and build
pipelines to process data efficiently. This makes the shell both interactive
and programmable—something remarkably different from other operating systems of
its time.</p><p>While many shells exist today, the original was the Bourne shell (sh), which
laid the foundation for everything that followed.</p><p>Finally, I want to emphasize that the shell is the gateway to UNIX power. It is
the first point of contact when learning UNIX, and mastering it unlocks the
system’s full potential. I believe the poster captures this perfectly—the shell
is at the heart of the wizard’s magic because it is the gateway to controlling
the system.</p></div></div></div></div><div class=side-container id=annotation-15-awk><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>15</span><div class=annotation-text><div class=annotation-title>AWK</div><div class=annotation-description>A language designed for text processing.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/AWK>AWK</a> is a domain specific language designed for text
processing, either run directly on files or used as part of a pipeline.</p><p>AWK was created at Bell Labs in the 1970s, and its name is
derived from the surnames of its authors: Alfred Aho, Peter Weinberger and Brian Kernighan.</p></div></div></div></div><div class=side-container id=annotation-18-B><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>18</span><div class=annotation-text><div class=annotation-title>B</div><div class=annotation-description>An early programming language used in the early Multics project.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/B_(programming_language)>B</a> is a programming language
designed for recursive, non-numeric, machine-independent applications.
B was derived from BCPL, and its name may possibly be a contraction of BCPL.
B is an almost extinct programming language, superseded by the more modern C language.</p><p>B was developed at Bell Labs circa 1969 by Ken Thompson and Dennis Ritchie.</p></div></div></div></div><div class=side-container id=annotation-07-backpressure><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>7</span><div class=annotation-text><div class=annotation-title>Backpressure</div><div class=annotation-description>Tell producers to stop sending data because the consumer cannot keep up</div></div></div><div class=annotation-body><p>When two processes communicate over a pipe, the process sending data is the
producer, and the process receiving data is the consumer. The OS maintains a
buffer to temporarily store data if the producer sends data faster than the
consumer can process it. However, if the buffer becomes full, the OS will block
the producer until space is available.</p><p>Was that the intention of the artist? You decide—is the valve handle in the
pipes a clever reference to UNIX back pressure, or is that a stretch?</p></div></div></div></div><div class=side-container id=annotation-40-banner><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>40</span><div class=annotation-text><div class=annotation-title>banner</div><div class=annotation-description>A program that outputs ASCII art</div></div></div><div class=annotation-body><p>Is it a coincidence that the poster&rsquo;s title appears in a
<a href=https://en.wikipedia.org/wiki/Banner_(Unix)>banner</a>? This Unix program was
designed to convert ordinary text into large ASCII characters for display
purposes.</p></div></div></div></div><div class=side-container id=annotation-21-boot><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>21</span><div class=annotation-text><div class=annotation-title>boot (or sock?)</div><div class=annotation-description>The booting process (or Unix Networking Sockets)</div></div></div><div class=annotation-body><p>I have to admit, this object looks more like a boot than a sock, but I find it
hard to believe that the author would leave out a reference to sockets,
considering how important they are—not only in UNIX but in the history of
operating systems.</p><p>For that reason, I see two possibilities:</p><ul><li><p>If it is a boot, it may represent the booting process of the UNIX operating
system, a fundamental part of bringing the system to life.</p></li><li><p>Alternatively, if it is a sock (granted, a thick and oversized one! 😄), it
is likely a playful reference to UNIX network sockets. Network sockets were an
abstraction pioneered by UNIX in BSD UNIX (4.2BSD, 1983). Sockets provided a
unified interface for interprocess communication (IPC), enabling processes to
communicate both locally (on the same machine) via UNIX domain sockets, and
over a network using TCP/IP. This innovation became foundational to modern
networking, and the socket API was later adopted by all major operating
systems, shaping how network programming is done today.</p></li></ul><p>For more on the history of BSD sockets, see <a href=https://en.wikipedia.org/wiki/Berkeley_sockets>Berkeley Sockets –
Wikipedia</a>, or read the
official Linux man page for
<a href=https://man7.org/linux/man-pages/man2/socket.2.html><code>socket()</code></a>.</p></div></div></div></div><div class=side-container id=annotation-19-cat><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>19</span><div class=annotation-text><div class=annotation-title>cat</div><div class=annotation-description>A standard Unix utility that reads files sequentially, writing them to standard output.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Cat_(Unix)><code>cat</code></a> derives its name from its function of
(con)<em>cat</em>enating files together.</p><p>The original version of <code>cat</code> was part of version 1 of Unix, and written by Ken Thompson and Dennis Ritchie.</p></div></div></div></div><div class=side-container id=annotation-32-curses><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>32</span><div class=annotation-text><div class=annotation-title>curses</div><div class=annotation-description>A terminal control library to aid in creating text user interfaces (TUI)</div></div></div><div class=annotation-body><p>The <a href=https://en.wikipedia.org/wiki/Curses_(programming_library)><code>curses</code></a> programming
library provides a layer of abstraction over sending graphical and positioning
data directly to allow for graphical elements and cursor positioning in Unix terminals.
The name is a pun on the term &ldquo;cursor optimization&rdquo;.</p><p>The first curses library was written by Ken Arnold and originally released with BSD UNIX.</p></div></div></div></div><div class=side-container id=annotation-08-daemons><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>8</span><div class=annotation-text><div class=annotation-title>Daemons</div><div class=annotation-description>Service processes that run in the background and supervise the system or provide functionality to other processes</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Daemon_(computing)>Daemons</a> are programs that run in the background
and are often started at system boot time. They respond to network requests, hardware activity,
or other programs by performing some task. Daemons such as cron may also perform
defined tasks at scheduled times.</p><p>The term was coined by the programmers at MIT&rsquo;s Project MAC. It is inspired by Maxwell&rsquo;s demon and
greek mythology, acting as a metaphor for a supernatural being working in the background.</p></div></div></div></div><div class=side-container id=annotation-26-dates><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>26</span><div class=annotation-text><div class=annotation-title>dates</div><div class=annotation-description>A command to display and set the system date</div></div></div><div class=annotation-body><p><a href=https://man7.org/linux/man-pages/man1/date.1.html><code>date</code></a> is a command to display and set a UNIX system date.</p><p>Unix time is currently defined as the number of non-leap seconds which have passed since 00:00:00 UTC on Thursday, 1 January 1970,
which is referred to as the Unix epoch.</p><p>The earliest versions of Unix time had a 32-bit integer incrementing at a rate of 60 Hz, which was the rate of the system clock
on the hardware of the early Unix systems.
Timestamps stored this way could only represent a range of a little over two and a quarter years.</p><p>The current epoch of 1 January 1970 00:00:00 UTC was selected arbitrarily by Unix engineers because it was considered a
convenient date to work with.</p></div></div></div></div><div class=side-container id=annotation-33-diff><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>33</span><div class=annotation-text><div class=annotation-title>diff</div><div class=annotation-description>A utility to find the differences between contents of a file</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Diff><code>diff</code></a> is a data comparison tool that computes
and displays the differences in the contents of files.
<code>diff</code> is line oriented and is often used to determine changes between two versions
of the same file.
For example, <code>diff</code> can be used to find which lines have changed in a source file,
allowing for only transmission of the changes, rather than the whole file.</p><p><code>diff</code> as developed in the early 1970s at Bell Labs.</p></div></div></div></div><div class=side-container id=annotation-38-tree-graph><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>38</span><div class=annotation-text><div class=annotation-title>Filesystem hierarchy</div><div class=annotation-description>Navigating the filesystem</div></div></div><div class=annotation-body><p>The tree-like shape of the liquid the wizard is manipulating may be a reference to
the UNIX filesystem hierarchy. UNIX organizes files and directories in a tree
structure, starting from the root (<code>/</code>) and branching into subdirectories.</p><p>Navigating this structure is a fundamental part of working with UNIX, typically done
through the shell using commands like <code>cd</code>, <code>ls</code>, and <code>pwd</code>. The tree shape could
symbolize this concept, visually representing how users move through directories,
access files, and execute commands.</p><p>Alternatively, the branching form could represent recursive operations or the
parent-child relationships in process trees, both key concepts in UNIX systems.</p><p>Some modern readers might associate the tree shape with version control systems like
Git, where branching is a common visual metaphor. However, this is likely not the
intended reference, as branching version control workflows were not as prevalent in
the UNIX world at the time the poster was created. Tools like SCCS (1972) and RCS
(1982) were available, but they focused more on linear versioning and file locking
than the branching models popular today.</p></div></div></div></div><div class=side-container id=annotation-13-fork><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>13</span><div class=annotation-text><div class=annotation-title>fork</div><div class=annotation-description>An operation whereby a process creates a copy of itself</div></div></div><div class=annotation-body><p>In multitasking operating systems, processes need a way to create new processes.
<a href=https://en.wikipedia.org/wiki/Fork_(system_call)>Forking</a> a process is typically the
only way of doing so in Unix-like systems.</p><p>One of the earliest references to a fork concept appeared in A Multiprocessor
System Design by Melvin Conway, published in 1962.</p></div></div></div></div><div class=side-container id=annotation-24-jfo-nroff><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>24</span><div class=annotation-text><div class=annotation-title>Jfo nroff</div><div class=annotation-description>A text formatting program that produces fixed width output for printers and terminals</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Nroff><code>nroff</code></a>, short for &ldquo;new roff&rdquo;
is a text-formatting program produces output suitable for simple fixed-width
printers and terminal windows.
It is an integral part of the Unix help system, being used to format man pages for display.</p><p>The letters <em>Jfo</em> stand for Joseph Frank Ossanna
who created the original version of <code>nroff</code> for Version 2 Unix.</p></div></div></div></div><div class=side-container id=annotation-05-kandr><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>5</span><div class=annotation-text><div class=annotation-title>Legendary figures</div><div class=annotation-description>Legendary figures in Unix history</div></div></div><div class=annotation-body><p>In the context of Unix history these three sets of initials refer to legendary
figures in the creation and development of Unix:</p><p>dmr: Dennis M. Ritchie, co-creator of Unix and creator of the C programming
language.</p><p>kt: Ken Thompson (often just “ken” in historical Unix references), co-creator
of Unix alongside Ritchie.</p><p>bwk: Brian W. Kernighan, co-author of several influential Unix programs and
books (including “The C Programming Language” and “The UNIX Programming
Environment”).</p></div></div></div></div><div class=side-container id=annotation-30-login><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>30</span><div class=annotation-text><div class=annotation-title>login</div><div class=annotation-description>The gateway into the system</div></div></div><div class=annotation-body><p><code>login</code> is the gateway into the system. It authenticates the user, initializes
the environment by changing to the user’s home directory, and spawns a process
running as the user (with their <code>uid</code> and <code>gid</code>), using their shell of choice.</p><p>Additionally, the standard input and output need to be attached to a terminal:
this could be a <strong>pseudo-terminal</strong> (if you are in a graphical interface or
using <code>ssh</code>), or a <strong>physical terminal</strong> (as was common at the time).</p></div></div></div></div><div class=side-container id=annotation-22-make><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>22</span><div class=annotation-text><div class=annotation-title>make</div><div class=annotation-description>A software development tool to perform ordered actions and manage dependencies</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Make_(software)>Make</a> is a command line interface
that reads in a configuration <code>Makefile</code> that is often used in code executable
compilation and automation.
Before Make, building on Unix mostly consisted of shell scripts written for each program&rsquo;s codebase.
Make&rsquo;s dependency ordering and out-of-date checking makes the build process more robust and more efficient.</p><p>Stuart Feldman was the original author of Make, completing an early version in April 1976 at
Bell Labs.</p></div></div></div></div><div class=side-container id=annotation-02-man><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>2</span><div class=annotation-text><div class=annotation-title>man</div><div class=annotation-description>Command to get detailed documentation of different Unix components, including other cmds.</div></div></div><div class=annotation-body><p>The <a href=https://man7.org/linux/man-pages/man1/man.1.html>man(1)</a>
command (short for manual) is used to display online reference manuals (man
pages) for commands, system calls, configuration files, and other aspects of
the system. man provides detailed documentation on how to use a command,
including its options, usage examples, related files, and other pertinent
details.</p><p>There&rsquo;s some ambiguity as to what the interpretation of the man in the window
could represent.
The man is holding a scythe, which could represent <a href=https://en.wikipedia.org/wiki/Zombie_process>reaping a process</a>.
Under Unix like systems, process reaping is when a parent process reads
the exit status of a spawned child process, allowing the child process
to be removed from the process table.</p><p>Others have suggested that the man could represent a <a href=https://en.wikipedia.org/wiki/Hacker>hacker</a>,
a term used to mean a skilled or clever programmer.</p></div></div></div></div><div class=side-container id=annotation-29-mbox><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>29</span><div class=annotation-text><div class=annotation-title>mbox</div><div class=annotation-description>The mail system format</div></div></div><div class=annotation-body><p><code>mbox</code> is a reference to the mail format from the early days of UNIX. UNIX was
one of the first operating systems to come with built-in email capabilities,
and it did so while staying true to its mantra: &ldquo;everything is a file.&rdquo; In the
<code>mbox</code> format, all email messages are stored in a single file, with new
messages simply appended to the end. By default, users&rsquo; mail was stored in
<code>/usr/mail/&lt;username></code>. This design naturally enabled the integration of
system logs and notifications to be sent via email—further embedding email as
a core part of the UNIX experience.</p></div></div></div></div><div class=side-container id=annotation-04-leak><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>4</span><div class=annotation-text><div class=annotation-title>Memory leaks</div><div class=annotation-description>Improper managing of memory by a computer program</div></div></div><div class=annotation-body><p>A memory leak occurs when a computer program improperly manages memory
allocation, failing to release memory that’s no longer needed. Over time, these
un-freed allocations accumulate, reducing the amount of available memory for
other processes and potentially leading to slowdowns or crashes.</p></div></div></div></div><div class=side-container id=annotation-10-null><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>10</span><div class=annotation-text><div class=annotation-title>null</div><div class=annotation-description>The null device is a device file that discards all data written to it but reports that the write operation succeeded.</div></div></div><div class=annotation-body><p>The <a href=https://en.wikipedia.org/wiki/Null_device>Null device</a> is a device file that discards all data written
to it but reports that the write operation succeeded.
This device is called /dev/null on Unix and Unix-like systems.
The null device is typically used for disposing of unwanted output streams of a process, or as a convenient empty file for input streams.</p></div></div></div></div><div class=side-container id=annotation-11-oregano><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>11</span><div class=annotation-text><div class=annotation-title>Oregano</div><div class=annotation-description>The Oregano incident</div></div></div><div class=annotation-body><p>From <a href=https://groups.google.com/g/comp.unix.wizards/c/qkiqSJWgEPE/m/E5BwZYMvXwAJ>Sarah Groves Hobart</a>:</p><blockquote><p>The oregano is reputedly referring to an incident in which one of the
original folks involved with BSD was hassled for coming across the
Canadian/U.S. border with a bag of what was assumed to be an illegal
substance, and turned out to be oregano.</p></blockquote></div></div></div></div><div class=side-container id=annotation-36-overflows><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>36</span><div class=annotation-text><div class=annotation-title>Overflows</div><div class=annotation-description>Buffer overflows</div></div></div><div class=annotation-body><p>This may be a bit of a stretch, but considering how prevalent buffer overflows
have been in the history of UNIX, the imagery might be intentional. The
overflowing liquid from the shell could be a visual reference to a buffer overflow.</p><p>A buffer overflow occurs when a program writes more data into a buffer (a fixed
block of memory) than it can hold. The excess data &ldquo;spills over&rdquo; into adjacent
memory, often overwriting critical information like return addresses, which can
cause crashes or open security vulnerabilities. Buffer overflows were (and still
are) a classic type of exploit in C programming on UNIX systems.</p><p>For more information, see
<a href=https://en.wikipedia.org/wiki/Buffer_overflow>Buffer overflow – Wikipedia</a>.</p></div></div></div></div><div class=side-container id=annotation-03-pipes><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>3</span><div class=annotation-text><div class=annotation-title>Pipes</div><div class=annotation-description>Connect cmd outputs to cmd inputs to create complex pipelines</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Pipeline_(Unix)>Pipes</a> are a
foundational feature in Unix that enable you to combine simple utilities into
more powerful workflows. By passing data from one command’s output to another
command’s input, pipes allow you to quickly create flexible, efficient, and
maintainable solutions directly at the command line. They are denoted in the
shell by the vertical bar character (|).</p></div></div></div></div><div class=side-container id=annotation-28-pwd><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>28</span><div class=annotation-text><div class=annotation-title>pwd</div><div class=annotation-description>A cmd to determine your location in the filesystem</div></div></div><div class=annotation-body><p><a href=https://man7.org/linux/man-pages/man1/pwd.1.html><code>pwd</code></a> is a simple command
that shows your current location in the filesystem. Is it a coincidence that
<code>pwd</code> is visually presented in a box? Maybe. But perhaps it’s a visual clue,
suggesting that <code>pwd</code> is a small, self-contained tool—like many classic UNIX
commands.</p></div></div></div></div><div class=side-container id=annotation-25-root><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>25</span><div class=annotation-text><div class=annotation-title>root</div><div class=annotation-description>The administrator account on UNIX systems</div></div></div><div class=annotation-body><p>The root user is the name often given to the administrator or superuser account
on UNIX systems.
In Unix-like systems, root is the conventional name of the user who has all rights or
permissions to all files and programs in all modes (e.g. single- or multi-user).
The root user can do many things an ordinary user cannot, such as changing the
ownership of files and binding to network ports numbered below 1024.</p></div></div></div></div><div class=side-container id=annotation-14-shell-script><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>14</span><div class=annotation-text><div class=annotation-title>Shell script</div><div class=annotation-description>The shell language</div></div></div><div class=annotation-body><p>A <a href=https://en.wikipedia.org/wiki/Shell_script>shell script</a> is a computer
program designed to be run by a Unix shell. The term is also used more
generally to mean the automated mode of running an operating system shell.</p></div></div></div></div><div class=side-container id=annotation-35-shell-symbols><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>35</span><div class=annotation-text><div class=annotation-title>Shell's symbols</div><div class=annotation-description>Symbols of the shell</div></div></div><div class=annotation-body><h3 id=shell-symbols-on-the-wizards-cloak>Shell Symbols on the Wizard&rsquo;s Cloak</h3><p>The wizard’s cloak is decorated with symbols that represent some of the most
important special characters used in the UNIX shell. These symbols are the
&ldquo;runes&rdquo; of UNIX power, allowing users to combine commands, redirect input and
output, and control processes with precision. Mastery of these symbols is part
of what transforms a regular user into a &ldquo;UNIX wizard.&rdquo;</p><h4 id=--job-control><code>%</code> – Job Control</h4><p>Used to <strong>refer to background jobs in the shell</strong>.</p><ul><li><code>jobs</code> → List background jobs.</li><li><code>fg %1</code> → Bring <strong>job 1 to the foreground</strong>.</li><li><code>bg %2</code> → Resume <strong>job 2 in the background</strong>.</li></ul><h4 id=--variable-expansion--shell-prompt><code>$</code> – Variable Expansion & Shell Prompt</h4><p>Represents <strong>variables and parameter substitution</strong>.</p><ul><li><code>$HOME</code> → Expands to <strong>the value of the <code>HOME</code> environment variable</strong>.</li><li><code>$?</code> → Shows <strong>the exit status of the last command</strong>.</li></ul><p>Also often <strong>appears as the shell prompt</strong> for <strong>a regular user</strong>.</p><h4 id=--output-redirection><code>></code> – Output Redirection</h4><p>Redirects <strong>standard output to a file</strong>.</p><ul><li><code>ls > files.txt</code> → Writes the <strong>output of <code>ls</code> into <code>files.txt</code></strong> (overwriting it).</li></ul><h4 id=--input-redirection><code>&lt;</code> – Input Redirection</h4><p>Redirects <strong>standard input from a file</strong>.</p><ul><li><code>sort &lt; input.txt</code> → Reads <strong>input from <code>input.txt</code> instead of the keyboard</strong>.</li></ul><h4 id=--wildcard-glob><code>*</code> – Wildcard (Glob)</h4><p><strong>Matches any number of characters</strong> in filenames.</p><ul><li><code>ls *.txt</code> → Lists <strong>all files ending in <code>.txt</code></strong>.</li><li><code>rm *</code> → <strong>Deletes all files in the current directory</strong> (Dangerous!).</li></ul><h4 id=--history-expansion><code>!</code> – History Expansion</h4><p><strong>Expands to previously executed commands</strong>.</p><ul><li><code>!!</code> → Repeats <strong>the last command</strong>.</li><li><code>!ls</code> → Repeats <strong>the last command starting with <code>ls</code></strong>.</li><li><code>!$</code> → Expands <strong>to the last argument of the previous command</strong>.</li></ul><h4 id=---test--conditional-expressions><code>[</code> <code>]</code> – Test / Conditional Expressions</h4><p>Used <strong>in shell conditionals</strong> and <strong><code>if</code> statements</strong>.</p><ul><li><code>[ -f file.txt ]</code> → <strong>Tests if <code>file.txt</code> is a regular file</strong>.</li><li>Common <strong>in shell scripting</strong>:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -f file.txt <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;File exists!&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div></li></ul></div></div></div></div><div class=side-container id=annotation-39-skull><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>39</span><div class=annotation-text><div class=annotation-title>skull</div><div class=annotation-description>Redirecting to stdout/stdin</div></div></div><div class=annotation-body><p>The skull connected to the shell may symbolize <code>/dev/null</code>, the special UNIX
device that discards all data written to it.
In UNIX, redirecting output to
<code>/dev/null</code> effectively sends it into a &ldquo;black hole,&rdquo; where it is lost
forever.
Output redirection is part of a broader
<a href=https://en.wikipedia.org/wiki/Standard_streams>standard stream</a> UNIX concept that
allows outputs of one process to be redirected to the input of another.</p><p>Another interpretation is that the spigot is reminiscent of a gargoyle, perhaps
referencing a UNIX <a href=https://en.wikipedia.org/wiki/Daemon_(computing)>daemon</a>
process.</p><p>See the (<a href=#annotation-10-null>/dev/null</a>) mark.</p></div></div></div></div><div class=side-container id=annotation-23-spawn><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>23</span><div class=annotation-text><div class=annotation-title>spawn</div><div class=annotation-description>An operation in which a new child process is created</div></div></div><div class=annotation-body><p>Spawning is the process of loading and executing a new child process.
Closely related is the idea of <code>fork</code> and <code>exec</code> that can be used
to simulate spawning, by forking a process, having the parent terminate
and <code>exec</code>ing the child into the desired spawn process.</p><p>POSIX allow for the concept of spawning by itself that can be made
to be more efficient than <code>fork</code> and <code>exec</code>.</p><p>The spawn metaphor had its early use in the VMS operating system from 1977.</p></div></div></div></div><div class=side-container id=annotation-31-spells><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>31</span><div class=annotation-text><div class=annotation-title>spells</div><div class=annotation-description>A command to check spelling</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Spell_(Unix)><code>spell</code></a> is the standard English
language spell checker for Unix and other Unix-like operating systems.</p><p>The original version was written by Stephen C. Johnson for Version 6 UNIX while at Bell Labs in 1976.</p></div></div></div></div><div class=side-container id=annotation-16-spool><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>16</span><div class=annotation-text><div class=annotation-title>spool</div><div class=annotation-description>/usr/spool</div></div></div><div class=annotation-body><p>This references <code>/usr/spool</code>, a directory used for temporary storage of data
that was waiting to be processed.</p><p>Thank you to Andrew Tannenbaum for pointing out that threads were not available
in the UNIX early days. Andew also sent me a link to <a href=https://commandcenter.blogspot.com/2020/01/unix-quiz.html>Rob Pike&rsquo;s UNIX
quiz</a>.</p></div></div></div></div><div class=side-container id=annotation-09-su><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>9</span><div class=annotation-text><div class=annotation-title>su</div><div class=annotation-description>Command to switch your identity</div></div></div><div class=annotation-body><p>The <a href=https://www.man7.org/linux/man-pages/man1/su.1.html>su</a> command (short for “substitute user” or
“switch user”) is used to start a shell under a different user account.
Typically, one of the most common uses of su is switching to the superuser
(root) account to gain administrative privileges.</p></div></div></div></div><div class=side-container id=annotation-12-tar><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>12</span><div class=annotation-text><div class=annotation-title>tar</div><div class=annotation-description>A software utility for collecting multiple files into a single archive file.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Tar_(computing)>Tar</a> is a software tool for collecting multiple
files into a single archive file, often called a tarball.
The name is derived from &ldquo;tape archive&rdquo;, as it was originally developed to write
data to sequential I/O devices with no file system of their own, such as devices that use magnetic tape.</p><p>The command-line utility was first introduced in the Version 7 Unix in January 1979, replacing the <code>tp</code> program (which in turn replaced <code>tap</code>).</p></div></div></div></div><div class=side-container id=annotation-37-tee><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>37</span><div class=annotation-text><div class=annotation-title>tee</div><div class=annotation-description>The T-junctions in the pipes, possibly a reference to the tee command.</div></div></div><div class=annotation-body><p>The T shape of the pipes may also reference the
<a href=https://man7.org/linux/man-pages/man1/tee.1.html><code>tee</code></a> command, a classic
utility in UNIX. The <code>tee</code> command is used to split the output of a command,
sending it to both a file and the next command in a pipeline.</p></div></div></div></div><div class=side-container id=annotation-06-c><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>6</span><div class=annotation-text><div class=annotation-title>The c programming language</div><div class=annotation-description>A key programming language in the creation of Unix</div></div></div><div class=annotation-body><p>C is deeply intertwined with the history and development of the Unix operating
system. Created by Dennis M. Ritchie at Bell Labs in the early 1970s, C was
used to rewrite Unix from low-level assembly into a higher-level language. This
shift made Unix significantly more portable across different hardware
platforms, fueling its rapid adoption in academia and industry. Over time, C
evolved into one of the most influential and widely used programming languages
in history.</p></div></div></div></div><div class=side-container id=annotation-34-traps><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>34</span><div class=annotation-text><div class=annotation-title>traps</div><div class=annotation-description>An inter-process message sent to a running program</div></div></div><div class=annotation-body><p>Traps, or <a href=https://en.wikipedia.org/wiki/Signal_(IPC)>signals</a>, are sent
from the kernel to a process, notifying the process of an event.
Common signals are interrupt, terminate or kill, with some signal
handling useful for inter-process communication and coordination.</p></div></div></div></div><div class=side-container id=annotation-17-troff><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>17</span><div class=annotation-text><div class=annotation-title>troff</div><div class=annotation-description>A program in formatting documents for the document processing system.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Troff>Troff</a> is the major component of a document processing system developed by Bell Labs for the Unix operating system.
Troff stands for &ldquo;typesetter roff&rdquo;, developed as a descendant to
<a href=https://en.wikipedia.org/wiki/Roff_(software)><code>roff</code></a>, where <code>roff</code> was
a Unix version of one of the earliest text formatting programs called <a href=https://en.wikipedia.org/wiki/TYPSET_and_RUNOFF><code>RUNOFF</code></a>.
A typical distribution of troff includes macros for many document styles, including ones for the Unix <code>man</code> pages.</p><p>Troff was developed by Bell Labs in the 1970s, where Joseph Ossanna created <code>troff</code> by modifying <code>nroff</code> to support multiple fonts and proportional spacing.</p></div></div></div></div><div class=side-container id=annotation-20-uucp><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>20</span><div class=annotation-text><div class=annotation-title>uucp</div><div class=annotation-description>A Unix program for file copy requests.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/UUCP><code>uucp</code></a> is one of the programs in the suite of Unix-to-Unix Copy programs.</p><p>UUCP was originally written at AT&amp;T Bell Laboratories by Mike Lesk.</p></div></div></div></div><div class=side-container id=annotation-41-wall><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>41</span><div class=annotation-text><div class=annotation-title>wall</div><div class=annotation-description>Utility to send a message to all users</div></div></div><div class=annotation-body><p>The <a href=https://www.man7.org/linux/man-pages/man1/wall.1.html>wall</a> command is a command-line utility that displays the contents of the specified file or otherwise its standard input on the terminals of all currently logged-in users. It is typically used by root to send out shutting down message to all users just before poweroff.</p></div></div></div></div><div class=side-container id=annotation-27-whoami><button class=close-btn>✖</button><div class=side-content><div class=annotation><div class=annotation-header><span class=annotation-number>27</span><div class=annotation-text><div class=annotation-title>whoami</div><div class=annotation-description>A command to provide the effective username of the current user</div></div></div><div class=annotation-body><p>Users on UNIX systems may want to
switch to other accounts, allowing for switching roles, escalation or deescalation of
privileges or might be logging into multiple machines across networks.
The <a href=https://en.wikipedia.org/wiki/Whoami><code>whoami</code></a> is a command to tell the invoker
what user they are logged in as.</p><p>The earliest versions were created in 2.9 BSD.</p></div></div></div></div><div id=poster-info class=poster-info-container><div class=poster-info><p>This is the <strong>UNIX Magic Poster</strong>, originally created by <strong>Gary Overacre</strong> in
the mid-1980s and published by UniTech Software.
It was later seen on display at a <a href=https://www.usenix.org/ target=_blank>USENIX
Conference</a>, reflecting its lasting influence in UNIX culture.
Head over to the <a href=https://github.com/drio/unixmagic target=_blank>repo</a> if you’d like to
contribute!</p><p>UNIX has been a major influence on my career
from the very beginning. My first exposure to UNIX was during my college years,
when I had to write most of my first-year programming assignments on terminals
connected to an <a href=https://en.wikipedia.org/wiki/HP-UX>HP-UX</a> main server.
I was immediately captivated by the simplicity
and power UNIX offered—especially compared to the operating systems I had used
before, like DOS and Windows.</p><p>That experience changed the way I thought about computers. From that point on,
I never looked back—UNIX has been my constant companion in my computing journey
ever since.
This project is my humble rendition—a celebration of UNIX and its lasting impact
on me.</p><div style=display:flex;justify-content:flex-end;font-weight:500;font-size:12px><pre>
                    $ ./enjoy
                    -drio
                </pre></div></div></div><div class=annotations><div id=annotation-01-shell class=annotation><div class=annotation-header><span class=annotation-number>1</span><div class=annotation-text><div class=annotation-title>Shell</div><div class=annotation-description>A gateway to controlling the system</div></div></div><div class=annotation-body><p>The prominent position of the shell in the UNIX Magic poster reflects its
central role in UNIX systems. The shell was (and still is) the primary
interface for interacting with the kernel, serving as the workbench of the UNIX
user. It is an incredibly powerful tool, allowing users to launch and
coordinate processes, perform complex computations, and interface directly with
the operating system.</p><p>The shell is not just an interface; it is also a full programming language.
Users can write scripts to automate tasks, control processes, and build
pipelines to process data efficiently. This makes the shell both interactive
and programmable—something remarkably different from other operating systems of
its time.</p><p>While many shells exist today, the original was the Bourne shell (sh), which
laid the foundation for everything that followed.</p><p>Finally, I want to emphasize that the shell is the gateway to UNIX power. It is
the first point of contact when learning UNIX, and mastering it unlocks the
system’s full potential. I believe the poster captures this perfectly—the shell
is at the heart of the wizard’s magic because it is the gateway to controlling
the system.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-02-man class=annotation><div class=annotation-header><span class=annotation-number>2</span><div class=annotation-text><div class=annotation-title>man</div><div class=annotation-description>Command to get detailed documentation of different Unix components, including other cmds.</div></div></div><div class=annotation-body><p>The <a href=https://man7.org/linux/man-pages/man1/man.1.html>man(1)</a>
command (short for manual) is used to display online reference manuals (man
pages) for commands, system calls, configuration files, and other aspects of
the system. man provides detailed documentation on how to use a command,
including its options, usage examples, related files, and other pertinent
details.</p><p>There&rsquo;s some ambiguity as to what the interpretation of the man in the window
could represent.
The man is holding a scythe, which could represent <a href=https://en.wikipedia.org/wiki/Zombie_process>reaping a process</a>.
Under Unix like systems, process reaping is when a parent process reads
the exit status of a spawned child process, allowing the child process
to be removed from the process table.</p><p>Others have suggested that the man could represent a <a href=https://en.wikipedia.org/wiki/Hacker>hacker</a>,
a term used to mean a skilled or clever programmer.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-03-pipes class=annotation><div class=annotation-header><span class=annotation-number>3</span><div class=annotation-text><div class=annotation-title>Pipes</div><div class=annotation-description>Connect cmd outputs to cmd inputs to create complex pipelines</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Pipeline_(Unix)>Pipes</a> are a
foundational feature in Unix that enable you to combine simple utilities into
more powerful workflows. By passing data from one command’s output to another
command’s input, pipes allow you to quickly create flexible, efficient, and
maintainable solutions directly at the command line. They are denoted in the
shell by the vertical bar character (|).</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-04-leak class=annotation><div class=annotation-header><span class=annotation-number>4</span><div class=annotation-text><div class=annotation-title>Memory leaks</div><div class=annotation-description>Improper managing of memory by a computer program</div></div></div><div class=annotation-body><p>A memory leak occurs when a computer program improperly manages memory
allocation, failing to release memory that’s no longer needed. Over time, these
un-freed allocations accumulate, reducing the amount of available memory for
other processes and potentially leading to slowdowns or crashes.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-05-kandr class=annotation><div class=annotation-header><span class=annotation-number>5</span><div class=annotation-text><div class=annotation-title>Legendary figures</div><div class=annotation-description>Legendary figures in Unix history</div></div></div><div class=annotation-body><p>In the context of Unix history these three sets of initials refer to legendary
figures in the creation and development of Unix:</p><p>dmr: Dennis M. Ritchie, co-creator of Unix and creator of the C programming
language.</p><p>kt: Ken Thompson (often just “ken” in historical Unix references), co-creator
of Unix alongside Ritchie.</p><p>bwk: Brian W. Kernighan, co-author of several influential Unix programs and
books (including “The C Programming Language” and “The UNIX Programming
Environment”).</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-06-c class=annotation><div class=annotation-header><span class=annotation-number>6</span><div class=annotation-text><div class=annotation-title>The c programming language</div><div class=annotation-description>A key programming language in the creation of Unix</div></div></div><div class=annotation-body><p>C is deeply intertwined with the history and development of the Unix operating
system. Created by Dennis M. Ritchie at Bell Labs in the early 1970s, C was
used to rewrite Unix from low-level assembly into a higher-level language. This
shift made Unix significantly more portable across different hardware
platforms, fueling its rapid adoption in academia and industry. Over time, C
evolved into one of the most influential and widely used programming languages
in history.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-07-backpressure class=annotation><div class=annotation-header><span class=annotation-number>7</span><div class=annotation-text><div class=annotation-title>Backpressure</div><div class=annotation-description>Tell producers to stop sending data because the consumer cannot keep up</div></div></div><div class=annotation-body><p>When two processes communicate over a pipe, the process sending data is the
producer, and the process receiving data is the consumer. The OS maintains a
buffer to temporarily store data if the producer sends data faster than the
consumer can process it. However, if the buffer becomes full, the OS will block
the producer until space is available.</p><p>Was that the intention of the artist? You decide—is the valve handle in the
pipes a clever reference to UNIX back pressure, or is that a stretch?</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-08-daemons class=annotation><div class=annotation-header><span class=annotation-number>8</span><div class=annotation-text><div class=annotation-title>Daemons</div><div class=annotation-description>Service processes that run in the background and supervise the system or provide functionality to other processes</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Daemon_(computing)>Daemons</a> are programs that run in the background
and are often started at system boot time. They respond to network requests, hardware activity,
or other programs by performing some task. Daemons such as cron may also perform
defined tasks at scheduled times.</p><p>The term was coined by the programmers at MIT&rsquo;s Project MAC. It is inspired by Maxwell&rsquo;s demon and
greek mythology, acting as a metaphor for a supernatural being working in the background.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-09-su class=annotation><div class=annotation-header><span class=annotation-number>9</span><div class=annotation-text><div class=annotation-title>su</div><div class=annotation-description>Command to switch your identity</div></div></div><div class=annotation-body><p>The <a href=https://www.man7.org/linux/man-pages/man1/su.1.html>su</a> command (short for “substitute user” or
“switch user”) is used to start a shell under a different user account.
Typically, one of the most common uses of su is switching to the superuser
(root) account to gain administrative privileges.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-10-null class=annotation><div class=annotation-header><span class=annotation-number>10</span><div class=annotation-text><div class=annotation-title>null</div><div class=annotation-description>The null device is a device file that discards all data written to it but reports that the write operation succeeded.</div></div></div><div class=annotation-body><p>The <a href=https://en.wikipedia.org/wiki/Null_device>Null device</a> is a device file that discards all data written
to it but reports that the write operation succeeded.
This device is called /dev/null on Unix and Unix-like systems.
The null device is typically used for disposing of unwanted output streams of a process, or as a convenient empty file for input streams.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-11-oregano class=annotation><div class=annotation-header><span class=annotation-number>11</span><div class=annotation-text><div class=annotation-title>Oregano</div><div class=annotation-description>The Oregano incident</div></div></div><div class=annotation-body><p>From <a href=https://groups.google.com/g/comp.unix.wizards/c/qkiqSJWgEPE/m/E5BwZYMvXwAJ>Sarah Groves Hobart</a>:</p><blockquote><p>The oregano is reputedly referring to an incident in which one of the
original folks involved with BSD was hassled for coming across the
Canadian/U.S. border with a bag of what was assumed to be an illegal
substance, and turned out to be oregano.</p></blockquote></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-12-tar class=annotation><div class=annotation-header><span class=annotation-number>12</span><div class=annotation-text><div class=annotation-title>tar</div><div class=annotation-description>A software utility for collecting multiple files into a single archive file.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Tar_(computing)>Tar</a> is a software tool for collecting multiple
files into a single archive file, often called a tarball.
The name is derived from &ldquo;tape archive&rdquo;, as it was originally developed to write
data to sequential I/O devices with no file system of their own, such as devices that use magnetic tape.</p><p>The command-line utility was first introduced in the Version 7 Unix in January 1979, replacing the <code>tp</code> program (which in turn replaced <code>tap</code>).</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-13-fork class=annotation><div class=annotation-header><span class=annotation-number>13</span><div class=annotation-text><div class=annotation-title>fork</div><div class=annotation-description>An operation whereby a process creates a copy of itself</div></div></div><div class=annotation-body><p>In multitasking operating systems, processes need a way to create new processes.
<a href=https://en.wikipedia.org/wiki/Fork_(system_call)>Forking</a> a process is typically the
only way of doing so in Unix-like systems.</p><p>One of the earliest references to a fork concept appeared in A Multiprocessor
System Design by Melvin Conway, published in 1962.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-14-shell-script class=annotation><div class=annotation-header><span class=annotation-number>14</span><div class=annotation-text><div class=annotation-title>Shell script</div><div class=annotation-description>The shell language</div></div></div><div class=annotation-body><p>A <a href=https://en.wikipedia.org/wiki/Shell_script>shell script</a> is a computer
program designed to be run by a Unix shell. The term is also used more
generally to mean the automated mode of running an operating system shell.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-15-awk class=annotation><div class=annotation-header><span class=annotation-number>15</span><div class=annotation-text><div class=annotation-title>AWK</div><div class=annotation-description>A language designed for text processing.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/AWK>AWK</a> is a domain specific language designed for text
processing, either run directly on files or used as part of a pipeline.</p><p>AWK was created at Bell Labs in the 1970s, and its name is
derived from the surnames of its authors: Alfred Aho, Peter Weinberger and Brian Kernighan.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-16-spool class=annotation><div class=annotation-header><span class=annotation-number>16</span><div class=annotation-text><div class=annotation-title>spool</div><div class=annotation-description>/usr/spool</div></div></div><div class=annotation-body><p>This references <code>/usr/spool</code>, a directory used for temporary storage of data
that was waiting to be processed.</p><p>Thank you to Andrew Tannenbaum for pointing out that threads were not available
in the UNIX early days. Andew also sent me a link to <a href=https://commandcenter.blogspot.com/2020/01/unix-quiz.html>Rob Pike&rsquo;s UNIX
quiz</a>.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-17-troff class=annotation><div class=annotation-header><span class=annotation-number>17</span><div class=annotation-text><div class=annotation-title>troff</div><div class=annotation-description>A program in formatting documents for the document processing system.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Troff>Troff</a> is the major component of a document processing system developed by Bell Labs for the Unix operating system.
Troff stands for &ldquo;typesetter roff&rdquo;, developed as a descendant to
<a href=https://en.wikipedia.org/wiki/Roff_(software)><code>roff</code></a>, where <code>roff</code> was
a Unix version of one of the earliest text formatting programs called <a href=https://en.wikipedia.org/wiki/TYPSET_and_RUNOFF><code>RUNOFF</code></a>.
A typical distribution of troff includes macros for many document styles, including ones for the Unix <code>man</code> pages.</p><p>Troff was developed by Bell Labs in the 1970s, where Joseph Ossanna created <code>troff</code> by modifying <code>nroff</code> to support multiple fonts and proportional spacing.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-18-B class=annotation><div class=annotation-header><span class=annotation-number>18</span><div class=annotation-text><div class=annotation-title>B</div><div class=annotation-description>An early programming language used in the early Multics project.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/B_(programming_language)>B</a> is a programming language
designed for recursive, non-numeric, machine-independent applications.
B was derived from BCPL, and its name may possibly be a contraction of BCPL.
B is an almost extinct programming language, superseded by the more modern C language.</p><p>B was developed at Bell Labs circa 1969 by Ken Thompson and Dennis Ritchie.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-19-cat class=annotation><div class=annotation-header><span class=annotation-number>19</span><div class=annotation-text><div class=annotation-title>cat</div><div class=annotation-description>A standard Unix utility that reads files sequentially, writing them to standard output.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Cat_(Unix)><code>cat</code></a> derives its name from its function of
(con)<em>cat</em>enating files together.</p><p>The original version of <code>cat</code> was part of version 1 of Unix, and written by Ken Thompson and Dennis Ritchie.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-20-uucp class=annotation><div class=annotation-header><span class=annotation-number>20</span><div class=annotation-text><div class=annotation-title>uucp</div><div class=annotation-description>A Unix program for file copy requests.</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/UUCP><code>uucp</code></a> is one of the programs in the suite of Unix-to-Unix Copy programs.</p><p>UUCP was originally written at AT&amp;T Bell Laboratories by Mike Lesk.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-21-boot class=annotation><div class=annotation-header><span class=annotation-number>21</span><div class=annotation-text><div class=annotation-title>boot (or sock?)</div><div class=annotation-description>The booting process (or Unix Networking Sockets)</div></div></div><div class=annotation-body><p>I have to admit, this object looks more like a boot than a sock, but I find it
hard to believe that the author would leave out a reference to sockets,
considering how important they are—not only in UNIX but in the history of
operating systems.</p><p>For that reason, I see two possibilities:</p><ul><li><p>If it is a boot, it may represent the booting process of the UNIX operating
system, a fundamental part of bringing the system to life.</p></li><li><p>Alternatively, if it is a sock (granted, a thick and oversized one! 😄), it
is likely a playful reference to UNIX network sockets. Network sockets were an
abstraction pioneered by UNIX in BSD UNIX (4.2BSD, 1983). Sockets provided a
unified interface for interprocess communication (IPC), enabling processes to
communicate both locally (on the same machine) via UNIX domain sockets, and
over a network using TCP/IP. This innovation became foundational to modern
networking, and the socket API was later adopted by all major operating
systems, shaping how network programming is done today.</p></li></ul><p>For more on the history of BSD sockets, see <a href=https://en.wikipedia.org/wiki/Berkeley_sockets>Berkeley Sockets –
Wikipedia</a>, or read the
official Linux man page for
<a href=https://man7.org/linux/man-pages/man2/socket.2.html><code>socket()</code></a>.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-22-make class=annotation><div class=annotation-header><span class=annotation-number>22</span><div class=annotation-text><div class=annotation-title>make</div><div class=annotation-description>A software development tool to perform ordered actions and manage dependencies</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Make_(software)>Make</a> is a command line interface
that reads in a configuration <code>Makefile</code> that is often used in code executable
compilation and automation.
Before Make, building on Unix mostly consisted of shell scripts written for each program&rsquo;s codebase.
Make&rsquo;s dependency ordering and out-of-date checking makes the build process more robust and more efficient.</p><p>Stuart Feldman was the original author of Make, completing an early version in April 1976 at
Bell Labs.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-23-spawn class=annotation><div class=annotation-header><span class=annotation-number>23</span><div class=annotation-text><div class=annotation-title>spawn</div><div class=annotation-description>An operation in which a new child process is created</div></div></div><div class=annotation-body><p>Spawning is the process of loading and executing a new child process.
Closely related is the idea of <code>fork</code> and <code>exec</code> that can be used
to simulate spawning, by forking a process, having the parent terminate
and <code>exec</code>ing the child into the desired spawn process.</p><p>POSIX allow for the concept of spawning by itself that can be made
to be more efficient than <code>fork</code> and <code>exec</code>.</p><p>The spawn metaphor had its early use in the VMS operating system from 1977.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-24-jfo-nroff class=annotation><div class=annotation-header><span class=annotation-number>24</span><div class=annotation-text><div class=annotation-title>Jfo nroff</div><div class=annotation-description>A text formatting program that produces fixed width output for printers and terminals</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Nroff><code>nroff</code></a>, short for &ldquo;new roff&rdquo;
is a text-formatting program produces output suitable for simple fixed-width
printers and terminal windows.
It is an integral part of the Unix help system, being used to format man pages for display.</p><p>The letters <em>Jfo</em> stand for Joseph Frank Ossanna
who created the original version of <code>nroff</code> for Version 2 Unix.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-25-root class=annotation><div class=annotation-header><span class=annotation-number>25</span><div class=annotation-text><div class=annotation-title>root</div><div class=annotation-description>The administrator account on UNIX systems</div></div></div><div class=annotation-body><p>The root user is the name often given to the administrator or superuser account
on UNIX systems.
In Unix-like systems, root is the conventional name of the user who has all rights or
permissions to all files and programs in all modes (e.g. single- or multi-user).
The root user can do many things an ordinary user cannot, such as changing the
ownership of files and binding to network ports numbered below 1024.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-26-dates class=annotation><div class=annotation-header><span class=annotation-number>26</span><div class=annotation-text><div class=annotation-title>dates</div><div class=annotation-description>A command to display and set the system date</div></div></div><div class=annotation-body><p><a href=https://man7.org/linux/man-pages/man1/date.1.html><code>date</code></a> is a command to display and set a UNIX system date.</p><p>Unix time is currently defined as the number of non-leap seconds which have passed since 00:00:00 UTC on Thursday, 1 January 1970,
which is referred to as the Unix epoch.</p><p>The earliest versions of Unix time had a 32-bit integer incrementing at a rate of 60 Hz, which was the rate of the system clock
on the hardware of the early Unix systems.
Timestamps stored this way could only represent a range of a little over two and a quarter years.</p><p>The current epoch of 1 January 1970 00:00:00 UTC was selected arbitrarily by Unix engineers because it was considered a
convenient date to work with.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-27-whoami class=annotation><div class=annotation-header><span class=annotation-number>27</span><div class=annotation-text><div class=annotation-title>whoami</div><div class=annotation-description>A command to provide the effective username of the current user</div></div></div><div class=annotation-body><p>Users on UNIX systems may want to
switch to other accounts, allowing for switching roles, escalation or deescalation of
privileges or might be logging into multiple machines across networks.
The <a href=https://en.wikipedia.org/wiki/Whoami><code>whoami</code></a> is a command to tell the invoker
what user they are logged in as.</p><p>The earliest versions were created in 2.9 BSD.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-28-pwd class=annotation><div class=annotation-header><span class=annotation-number>28</span><div class=annotation-text><div class=annotation-title>pwd</div><div class=annotation-description>A cmd to determine your location in the filesystem</div></div></div><div class=annotation-body><p><a href=https://man7.org/linux/man-pages/man1/pwd.1.html><code>pwd</code></a> is a simple command
that shows your current location in the filesystem. Is it a coincidence that
<code>pwd</code> is visually presented in a box? Maybe. But perhaps it’s a visual clue,
suggesting that <code>pwd</code> is a small, self-contained tool—like many classic UNIX
commands.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-29-mbox class=annotation><div class=annotation-header><span class=annotation-number>29</span><div class=annotation-text><div class=annotation-title>mbox</div><div class=annotation-description>The mail system format</div></div></div><div class=annotation-body><p><code>mbox</code> is a reference to the mail format from the early days of UNIX. UNIX was
one of the first operating systems to come with built-in email capabilities,
and it did so while staying true to its mantra: &ldquo;everything is a file.&rdquo; In the
<code>mbox</code> format, all email messages are stored in a single file, with new
messages simply appended to the end. By default, users&rsquo; mail was stored in
<code>/usr/mail/&lt;username></code>. This design naturally enabled the integration of
system logs and notifications to be sent via email—further embedding email as
a core part of the UNIX experience.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-30-login class=annotation><div class=annotation-header><span class=annotation-number>30</span><div class=annotation-text><div class=annotation-title>login</div><div class=annotation-description>The gateway into the system</div></div></div><div class=annotation-body><p><code>login</code> is the gateway into the system. It authenticates the user, initializes
the environment by changing to the user’s home directory, and spawns a process
running as the user (with their <code>uid</code> and <code>gid</code>), using their shell of choice.</p><p>Additionally, the standard input and output need to be attached to a terminal:
this could be a <strong>pseudo-terminal</strong> (if you are in a graphical interface or
using <code>ssh</code>), or a <strong>physical terminal</strong> (as was common at the time).</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-31-spells class=annotation><div class=annotation-header><span class=annotation-number>31</span><div class=annotation-text><div class=annotation-title>spells</div><div class=annotation-description>A command to check spelling</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Spell_(Unix)><code>spell</code></a> is the standard English
language spell checker for Unix and other Unix-like operating systems.</p><p>The original version was written by Stephen C. Johnson for Version 6 UNIX while at Bell Labs in 1976.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-32-curses class=annotation><div class=annotation-header><span class=annotation-number>32</span><div class=annotation-text><div class=annotation-title>curses</div><div class=annotation-description>A terminal control library to aid in creating text user interfaces (TUI)</div></div></div><div class=annotation-body><p>The <a href=https://en.wikipedia.org/wiki/Curses_(programming_library)><code>curses</code></a> programming
library provides a layer of abstraction over sending graphical and positioning
data directly to allow for graphical elements and cursor positioning in Unix terminals.
The name is a pun on the term &ldquo;cursor optimization&rdquo;.</p><p>The first curses library was written by Ken Arnold and originally released with BSD UNIX.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-33-diff class=annotation><div class=annotation-header><span class=annotation-number>33</span><div class=annotation-text><div class=annotation-title>diff</div><div class=annotation-description>A utility to find the differences between contents of a file</div></div></div><div class=annotation-body><p><a href=https://en.wikipedia.org/wiki/Diff><code>diff</code></a> is a data comparison tool that computes
and displays the differences in the contents of files.
<code>diff</code> is line oriented and is often used to determine changes between two versions
of the same file.
For example, <code>diff</code> can be used to find which lines have changed in a source file,
allowing for only transmission of the changes, rather than the whole file.</p><p><code>diff</code> as developed in the early 1970s at Bell Labs.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-34-traps class=annotation><div class=annotation-header><span class=annotation-number>34</span><div class=annotation-text><div class=annotation-title>traps</div><div class=annotation-description>An inter-process message sent to a running program</div></div></div><div class=annotation-body><p>Traps, or <a href=https://en.wikipedia.org/wiki/Signal_(IPC)>signals</a>, are sent
from the kernel to a process, notifying the process of an event.
Common signals are interrupt, terminate or kill, with some signal
handling useful for inter-process communication and coordination.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-35-shell-symbols class=annotation><div class=annotation-header><span class=annotation-number>35</span><div class=annotation-text><div class=annotation-title>Shell's symbols</div><div class=annotation-description>Symbols of the shell</div></div></div><div class=annotation-body><h3 id=shell-symbols-on-the-wizards-cloak>Shell Symbols on the Wizard&rsquo;s Cloak</h3><p>The wizard’s cloak is decorated with symbols that represent some of the most
important special characters used in the UNIX shell. These symbols are the
&ldquo;runes&rdquo; of UNIX power, allowing users to combine commands, redirect input and
output, and control processes with precision. Mastery of these symbols is part
of what transforms a regular user into a &ldquo;UNIX wizard.&rdquo;</p><h4 id=--job-control><code>%</code> – Job Control</h4><p>Used to <strong>refer to background jobs in the shell</strong>.</p><ul><li><code>jobs</code> → List background jobs.</li><li><code>fg %1</code> → Bring <strong>job 1 to the foreground</strong>.</li><li><code>bg %2</code> → Resume <strong>job 2 in the background</strong>.</li></ul><h4 id=--variable-expansion--shell-prompt><code>$</code> – Variable Expansion & Shell Prompt</h4><p>Represents <strong>variables and parameter substitution</strong>.</p><ul><li><code>$HOME</code> → Expands to <strong>the value of the <code>HOME</code> environment variable</strong>.</li><li><code>$?</code> → Shows <strong>the exit status of the last command</strong>.</li></ul><p>Also often <strong>appears as the shell prompt</strong> for <strong>a regular user</strong>.</p><h4 id=--output-redirection><code>></code> – Output Redirection</h4><p>Redirects <strong>standard output to a file</strong>.</p><ul><li><code>ls > files.txt</code> → Writes the <strong>output of <code>ls</code> into <code>files.txt</code></strong> (overwriting it).</li></ul><h4 id=--input-redirection><code>&lt;</code> – Input Redirection</h4><p>Redirects <strong>standard input from a file</strong>.</p><ul><li><code>sort &lt; input.txt</code> → Reads <strong>input from <code>input.txt</code> instead of the keyboard</strong>.</li></ul><h4 id=--wildcard-glob><code>*</code> – Wildcard (Glob)</h4><p><strong>Matches any number of characters</strong> in filenames.</p><ul><li><code>ls *.txt</code> → Lists <strong>all files ending in <code>.txt</code></strong>.</li><li><code>rm *</code> → <strong>Deletes all files in the current directory</strong> (Dangerous!).</li></ul><h4 id=--history-expansion><code>!</code> – History Expansion</h4><p><strong>Expands to previously executed commands</strong>.</p><ul><li><code>!!</code> → Repeats <strong>the last command</strong>.</li><li><code>!ls</code> → Repeats <strong>the last command starting with <code>ls</code></strong>.</li><li><code>!$</code> → Expands <strong>to the last argument of the previous command</strong>.</li></ul><h4 id=---test--conditional-expressions><code>[</code> <code>]</code> – Test / Conditional Expressions</h4><p>Used <strong>in shell conditionals</strong> and <strong><code>if</code> statements</strong>.</p><ul><li><code>[ -f file.txt ]</code> → <strong>Tests if <code>file.txt</code> is a regular file</strong>.</li><li>Common <strong>in shell scripting</strong>:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -f file.txt <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;File exists!&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div></li></ul></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-36-overflows class=annotation><div class=annotation-header><span class=annotation-number>36</span><div class=annotation-text><div class=annotation-title>Overflows</div><div class=annotation-description>Buffer overflows</div></div></div><div class=annotation-body><p>This may be a bit of a stretch, but considering how prevalent buffer overflows
have been in the history of UNIX, the imagery might be intentional. The
overflowing liquid from the shell could be a visual reference to a buffer overflow.</p><p>A buffer overflow occurs when a program writes more data into a buffer (a fixed
block of memory) than it can hold. The excess data &ldquo;spills over&rdquo; into adjacent
memory, often overwriting critical information like return addresses, which can
cause crashes or open security vulnerabilities. Buffer overflows were (and still
are) a classic type of exploit in C programming on UNIX systems.</p><p>For more information, see
<a href=https://en.wikipedia.org/wiki/Buffer_overflow>Buffer overflow – Wikipedia</a>.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-37-tee class=annotation><div class=annotation-header><span class=annotation-number>37</span><div class=annotation-text><div class=annotation-title>tee</div><div class=annotation-description>The T-junctions in the pipes, possibly a reference to the tee command.</div></div></div><div class=annotation-body><p>The T shape of the pipes may also reference the
<a href=https://man7.org/linux/man-pages/man1/tee.1.html><code>tee</code></a> command, a classic
utility in UNIX. The <code>tee</code> command is used to split the output of a command,
sending it to both a file and the next command in a pipeline.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-38-tree-graph class=annotation><div class=annotation-header><span class=annotation-number>38</span><div class=annotation-text><div class=annotation-title>Filesystem hierarchy</div><div class=annotation-description>Navigating the filesystem</div></div></div><div class=annotation-body><p>The tree-like shape of the liquid the wizard is manipulating may be a reference to
the UNIX filesystem hierarchy. UNIX organizes files and directories in a tree
structure, starting from the root (<code>/</code>) and branching into subdirectories.</p><p>Navigating this structure is a fundamental part of working with UNIX, typically done
through the shell using commands like <code>cd</code>, <code>ls</code>, and <code>pwd</code>. The tree shape could
symbolize this concept, visually representing how users move through directories,
access files, and execute commands.</p><p>Alternatively, the branching form could represent recursive operations or the
parent-child relationships in process trees, both key concepts in UNIX systems.</p><p>Some modern readers might associate the tree shape with version control systems like
Git, where branching is a common visual metaphor. However, this is likely not the
intended reference, as branching version control workflows were not as prevalent in
the UNIX world at the time the poster was created. Tools like SCCS (1972) and RCS
(1982) were available, but they focused more on linear versioning and file locking
than the branching models popular today.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-39-skull class=annotation><div class=annotation-header><span class=annotation-number>39</span><div class=annotation-text><div class=annotation-title>skull</div><div class=annotation-description>Redirecting to stdout/stdin</div></div></div><div class=annotation-body><p>The skull connected to the shell may symbolize <code>/dev/null</code>, the special UNIX
device that discards all data written to it.
In UNIX, redirecting output to
<code>/dev/null</code> effectively sends it into a &ldquo;black hole,&rdquo; where it is lost
forever.
Output redirection is part of a broader
<a href=https://en.wikipedia.org/wiki/Standard_streams>standard stream</a> UNIX concept that
allows outputs of one process to be redirected to the input of another.</p><p>Another interpretation is that the spigot is reminiscent of a gargoyle, perhaps
referencing a UNIX <a href=https://en.wikipedia.org/wiki/Daemon_(computing)>daemon</a>
process.</p><p>See the (<a href=#annotation-10-null>/dev/null</a>) mark.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-40-banner class=annotation><div class=annotation-header><span class=annotation-number>40</span><div class=annotation-text><div class=annotation-title>banner</div><div class=annotation-description>A program that outputs ASCII art</div></div></div><div class=annotation-body><p>Is it a coincidence that the poster&rsquo;s title appears in a
<a href=https://en.wikipedia.org/wiki/Banner_(Unix)>banner</a>? This Unix program was
designed to convert ordinary text into large ASCII characters for display
purposes.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div><div id=annotation-41-wall class=annotation><div class=annotation-header><span class=annotation-number>41</span><div class=annotation-text><div class=annotation-title>wall</div><div class=annotation-description>Utility to send a message to all users</div></div></div><div class=annotation-body><p>The <a href=https://www.man7.org/linux/man-pages/man1/wall.1.html>wall</a> command is a command-line utility that displays the contents of the specified file or otherwise its standard input on the terminals of all currently logged-in users. It is typically used by root to send out shutting down message to all users just before poweroff.</p></div><div class=annotation-footer><a href=# class=back-to-top>🔝</a></div></div></div><div class=footer>Made with Unix ❤️ by <a href=https://driohq.net target=_blank>drio</a></div><script>function positionMarkers(){const t=document.getElementById("poster"),s=document.getElementById("poster-container"),o=document.querySelectorAll(".marker");if(!t.complete){t.onload=positionMarkers;return}const e=t.getBoundingClientRect(),n=s.getBoundingClientRect();o.forEach(t=>{const s=parseFloat(t.getAttribute("data-left")),o=parseFloat(t.getAttribute("data-top"));t.style.left=`${s/100*e.width+e.left-n.left}px`,t.style.top=`${o/100*e.height+e.top-n.top}px`})}document.addEventListener("DOMContentLoaded",function(){const t=document.querySelectorAll(".marker"),n=document.querySelectorAll(".close-btn"),e=document.getElementById("poster");window.addEventListener("resize",positionMarkers),e.complete?(positionMarkers(),finishLoading()):e.onload=()=>{positionMarkers(),finishLoading()},t.forEach(e=>{e.addEventListener("click",function(){const t=this.getAttribute("data-id"),e=document.getElementById(t);e&&(document.querySelectorAll(".side-container").forEach(e=>e.classList.remove("active")),e.classList.add("active"))})}),n.forEach(e=>{e.addEventListener("click",function(){this.parentElement.classList.remove("active")})}),document.addEventListener("click",function(e){!e.target.closest(".side-container")&&!e.target.classList.contains("marker")&&document.querySelectorAll(".side-container").forEach(e=>e.classList.remove("active"))})});function finishLoading(){document.body.classList.add("ready");const e=document.getElementById("loading");e&&(e.style.transition="opacity 0.7s ease",e.style.opacity="0",setTimeout(()=>e.style.display="none",400))}window.addEventListener("load",finishLoading)</script></body></html>